/*
Deployment script for Purchasing.Db

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "Purchasing.Db"
:setvar DefaultFilePrefix "Purchasing.Db"
:setvar DefaultDataPath "C:\Users\Sylvestre\Documents\Visual Studio 2010\Projects\Purchasing\Purchasing.Db\Sandbox\"
:setvar DefaultLogPath "C:\Users\Sylvestre\Documents\Visual Studio 2010\Projects\Purchasing\Purchasing.Db\Sandbox\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
PRINT N'Creating [PrePurchasing]...';


GO
ALTER DATABASE [$(DatabaseName)]
    ADD FILE (NAME = [PrePurchasing], FILENAME = 'E:\DB\PrePurchasing.mdf', SIZE = 243712 KB, FILEGROWTH = 1024 KB) TO FILEGROUP [PRIMARY];


GO
PRINT N'Creating [PrePurchasing_KfsData]...';


GO
ALTER DATABASE [$(DatabaseName)]
    ADD FILE (NAME = [PrePurchasing_KfsData], FILENAME = 'E:\DB\PrePurchasing_KfsData.ndf', SIZE = 328704 KB, FILEGROWTH = 1024 KB) TO FILEGROUP [Secondary];


GO
PRINT N'Creating [PrePurchasing_KfsData_log1]...';


GO
ALTER DATABASE [$(DatabaseName)]
    ADD LOG FILE (NAME = [PrePurchasing_KfsData_log1], FILENAME = 'E:\DB\PrePurchasing_KfsData_log1.ldf', SIZE = 7607488 KB, MAXSIZE = 2097152 MB, FILEGROWTH = 10 %);


GO
PRINT N'Creating [PrePurchasing_log]...';


GO
ALTER DATABASE [$(DatabaseName)]
    ADD LOG FILE (NAME = [PrePurchasing_log], FILENAME = 'E:\DB\PrePurchasing_log.ldf', SIZE = 10087872 KB, MAXSIZE = 2097152 MB, FILEGROWTH = 10 %);


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
        
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
PRINT N'Creating [CustomFieldAnswers_Answer_SDX]...';


GO
CREATE FULLTEXT CATALOG [CustomFieldAnswers_Answer_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [LineItems_DescriptionUrlNotesCatalognumberCommoditycode_SIDX]...';


GO
CREATE FULLTEXT CATALOG [LineItems_DescriptionUrlNotesCatalognumberCommoditycode_SIDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [OrderComments_Answer_SDX]...';


GO
CREATE FULLTEXT CATALOG [OrderComments_Answer_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Orders_justification_SIDX]...';


GO
CREATE FULLTEXT CATALOG [Orders_justification_SIDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [vAccounts_IdName_SDX]...';


GO
CREATE FULLTEXT CATALOG [vAccounts_IdName_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [vBuildings_BuildingCodeBuildingName_SDX]...';


GO
CREATE FULLTEXT CATALOG [vBuildings_BuildingCodeBuildingName_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [vCommodities_IdName_SDX]...';


GO
CREATE FULLTEXT CATALOG [vCommodities_IdName_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [vVendors_Name_SDX]...';


GO
CREATE FULLTEXT CATALOG [vVendors_Name_SDX]
    WITH ACCENT_SENSITIVITY = ON
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [EvenOddPartitionFunction]...';


GO
CREATE PARTITION FUNCTION [EvenOddPartitionFunction](INT)
    AS RANGE
    FOR VALUES (1);


GO
PRINT N'Creating [EvenOddPartitionScheme]...';


GO
CREATE PARTITION SCHEME [EvenOddPartitionScheme]
    AS PARTITION [EvenOddPartitionFunction]
    TO ([PRIMARY], [Secondary]);


GO
PRINT N'Creating [dbo].[Approvals]...';


GO
CREATE TABLE [dbo].[Approvals] (
    [Id]                INT          IDENTITY (1, 1) NOT NULL,
    [UserId]            VARCHAR (10) NULL,
    [SecondaryUserId]   VARCHAR (10) NULL,
    [Completed]         BIT          NOT NULL,
    [OrderStatusCodeId] CHAR (2)     NOT NULL,
    [OrderId]           INT          NOT NULL,
    [SplitId]           INT          NULL,
    CONSTRAINT [PK_Approvals_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[Attachments]...';


GO
CREATE TABLE [dbo].[Attachments] (
    [Id]          UNIQUEIDENTIFIER NOT NULL,
    [Filename]    VARCHAR (100)    NOT NULL,
    [ContentType] VARCHAR (200)    NOT NULL,
    [Contents]    VARBINARY (MAX)  NOT NULL,
    [OrderId]     INT              NULL,
    [DateCreated] DATETIME         NOT NULL,
    [UserId]      VARCHAR (10)     NOT NULL,
    CONSTRAINT [PK_Attachments] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[Audits]...';


GO
CREATE TABLE [dbo].[Audits] (
    [ID]          UNIQUEIDENTIFIER NOT NULL,
    [ObjectName]  VARCHAR (50)     NOT NULL,
    [ObjectId]    VARCHAR (50)     NULL,
    [AuditAction] CHAR (1)         NOT NULL,
    [Username]    NVARCHAR (256)   NOT NULL,
    [AuditDate]   DATETIME         NOT NULL,
    CONSTRAINT [PK_Audit] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [dbo].[AutoApprovals]...';


GO
CREATE TABLE [dbo].[AutoApprovals] (
    [Id]           INT          IDENTITY (1, 1) NOT NULL,
    [TargetUserId] VARCHAR (10) NULL,
    [AccountId]    VARCHAR (10) NULL,
    [MaxAmount]    MONEY        NOT NULL,
    [LessThan]     BIT          NOT NULL,
    [Equal]        BIT          NOT NULL,
    [IsActive]     BIT          NOT NULL,
    [UserId]       VARCHAR (10) NOT NULL,
    [Expiration]   DATE         NULL,
    CONSTRAINT [PK_AutoApprovals] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[BugTracking]...';


GO
CREATE TABLE [dbo].[BugTracking] (
    [Id]              INT           IDENTITY (1, 1) NOT NULL,
    [OrderId]         INT           NOT NULL,
    [UserId]          VARCHAR (20)  NOT NULL,
    [DateTimeStamp]   DATETIME      NOT NULL,
    [TrackingMessage] VARCHAR (500) NULL,
    [SplitId]         INT           NULL,
    [LineItemId]      INT           NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[ColumnPreferences]...';


GO
CREATE TABLE [dbo].[ColumnPreferences] (
    [Id]                      VARCHAR (10) NOT NULL,
    [ShowRequestNumber]       BIT          NOT NULL,
    [ShowWorkgroup]           BIT          NOT NULL,
    [ShowVendor]              BIT          NOT NULL,
    [ShowCreatedBy]           BIT          NOT NULL,
    [ShowCreatedDate]         BIT          NOT NULL,
    [ShowLineItems]           BIT          NOT NULL,
    [ShowTotalAmount]         BIT          NOT NULL,
    [ShowStatus]              BIT          NOT NULL,
    [ShowApprover]            BIT          NOT NULL,
    [ShowAccountManager]      BIT          NOT NULL,
    [ShowPurchaser]           BIT          NOT NULL,
    [ShowAccountNumber]       BIT          NOT NULL,
    [ShowShipTo]              BIT          NOT NULL,
    [ShowAllowBackorder]      BIT          NOT NULL,
    [ShowRestrictedOrder]     BIT          NOT NULL,
    [ShowNeededDate]          BIT          NOT NULL,
    [ShowShippingType]        BIT          NOT NULL,
    [ShowPurchaseOrderNumber] BIT          NOT NULL,
    [ShowLastActedOnDate]     BIT          NOT NULL,
    [ShowDaysNotActedOn]      BIT          NOT NULL,
    [ShowLastActedOnBy]       BIT          NOT NULL,
    [ShowOrderReceived]       BIT          NOT NULL,
    [ShowOrderType]           BIT          NOT NULL,
    [DisplayRows]             INT          NOT NULL,
    [ShowHasSplits]           BIT          NOT NULL
);


GO
PRINT N'Creating [dbo].[ConditionalApproval]...';


GO
CREATE TABLE [dbo].[ConditionalApproval] (
    [Id]                  INT           IDENTITY (1, 1) NOT NULL,
    [Question]            VARCHAR (MAX) NOT NULL,
    [PrimaryApproverId]   VARCHAR (10)  NOT NULL,
    [SecondaryApproverId] VARCHAR (10)  NULL,
    [WorkgroupId]         INT           NULL,
    [OrganizationId]      VARCHAR (10)  NULL,
    CONSTRAINT [PK_ConditionalApproval_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ControlledSubstanceInformation]...';


GO
CREATE TABLE [dbo].[ControlledSubstanceInformation] (
    [Id]            INT           IDENTITY (1, 1) NOT NULL,
    [ClassSchedule] VARCHAR (10)  NOT NULL,
    [Use]           VARCHAR (200) NOT NULL,
    [StorageSite]   VARCHAR (50)  NOT NULL,
    [Custodian]     VARCHAR (200) NOT NULL,
    [EndUser]       VARCHAR (200) NOT NULL,
    [OrderId]       INT           NOT NULL,
    CONSTRAINT [PK_AuthorizationNumbers] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[CustomFieldAnswers]...';


GO
CREATE TABLE [dbo].[CustomFieldAnswers] (
    [Id]            INT           IDENTITY (1, 1) NOT NULL,
    [CustomFieldId] INT           NOT NULL,
    [Answer]        VARCHAR (MAX) NOT NULL,
    [OrderId]       INT           NOT NULL,
    CONSTRAINT [PK_CustomFieldAnswers] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[CustomFields]...';


GO
CREATE TABLE [dbo].[CustomFields] (
    [Id]             INT           IDENTITY (1, 1) NOT NULL,
    [Name]           VARCHAR (MAX) NOT NULL,
    [OrganizationId] VARCHAR (10)  NOT NULL,
    [Rank]           INT           NOT NULL,
    [IsActive]       BIT           NOT NULL,
    [IsRequired]     BIT           NOT NULL,
    CONSTRAINT [PK_CustomFields] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[ELMAH_Error]...';


GO
CREATE TABLE [dbo].[ELMAH_Error] (
    [ErrorId]     UNIQUEIDENTIFIER NOT NULL,
    [Application] NVARCHAR (60)    NOT NULL,
    [Host]        NVARCHAR (50)    NOT NULL,
    [Type]        NVARCHAR (100)   NOT NULL,
    [Source]      NVARCHAR (60)    NOT NULL,
    [Message]     NVARCHAR (500)   NOT NULL,
    [User]        NVARCHAR (50)    NOT NULL,
    [StatusCode]  INT              NOT NULL,
    [TimeUtc]     DATETIME         NOT NULL,
    [Sequence]    INT              IDENTITY (1, 1) NOT NULL,
    [AllXml]      NTEXT            NOT NULL,
    CONSTRAINT [PK_ELMAH_Error] PRIMARY KEY NONCLUSTERED ([ErrorId] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ELMAH_Error].[IX_ELMAH_Error_App_Time_Seq]...';


GO
CREATE NONCLUSTERED INDEX [IX_ELMAH_Error_App_Time_Seq]
    ON [dbo].[ELMAH_Error]([Application] ASC, [TimeUtc] DESC, [Sequence] DESC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[EmailPreferences]...';


GO
CREATE TABLE [dbo].[EmailPreferences] (
    [Id]                                  VARCHAR (10) NOT NULL,
    [RequesterOrderSubmission]            BIT          NOT NULL,
    [RequesterApproverApproved]           BIT          NOT NULL,
    [RequesterApproverChanged]            BIT          NOT NULL,
    [RequesterAccountManagerApproved]     BIT          NOT NULL,
    [RequesterAccountManagerChanged]      BIT          NOT NULL,
    [RequesterPurchaserAction]            BIT          NOT NULL,
    [RequesterPurchaserChanged]           BIT          NOT NULL,
    [RequesterKualiProcessed]             BIT          NOT NULL,
    [RequesterKualiApproved]              BIT          NOT NULL,
    [RequesterReceived]                   BIT          NOT NULL,
    [ApproverAccountManagerApproved]      BIT          NOT NULL,
    [ApproverAccountManagerDenied]        BIT          NOT NULL,
    [ApproverKualiApproved]               BIT          NOT NULL,
    [ApproverPurchaserProcessed]          BIT          NOT NULL,
    [ApproverOrderCompleted]              BIT          NOT NULL,
    [ApproverOrderArrive]                 BIT          NOT NULL,
    [AccountManagerKualiApproved]         BIT          NOT NULL,
    [AccountManagerOrderCompleted]        BIT          NOT NULL,
    [AccountManagerPurchaserProcessed]    BIT          NOT NULL,
    [AccountManagerOrderArrive]           BIT          NOT NULL,
    [PurchaserKualiApproved]              BIT          NOT NULL,
    [PurchaserOrderCompleted]             BIT          NOT NULL,
    [PurchaserOrderArrive]                BIT          NOT NULL,
    [PurchaserKfsItemReceived]            BIT          NOT NULL,
    [PurchaserPCardItemReceived]          BIT          NOT NULL,
    [PurchaserCampusServicesItemReceived] BIT          NOT NULL,
    [NotificationType]                    VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_EmailPreferences] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[EmailQueue]...';


GO
CREATE TABLE [dbo].[EmailQueue] (
    [Id]               UNIQUEIDENTIFIER NOT NULL,
    [UserId]           VARCHAR (10)     NULL,
    [Text]             VARCHAR (MAX)    NOT NULL,
    [OrderId]          INT              NOT NULL,
    [DateTimeCreated]  DATETIME2 (7)    NOT NULL,
    [Pending]          BIT              NOT NULL,
    [DateTimeSent]     DATETIME2 (7)    NULL,
    [Status]           VARCHAR (MAX)    NULL,
    [Email]            VARCHAR (100)    NULL,
    [NotificationType] VARCHAR (50)     NOT NULL,
    CONSTRAINT [PK_EmailQueue] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[Faqs]...';


GO
CREATE TABLE [dbo].[Faqs] (
    [Id]       INT           IDENTITY (1, 1) NOT NULL,
    [Category] VARCHAR (50)  NOT NULL,
    [Question] VARCHAR (MAX) NOT NULL,
    [Answer]   VARCHAR (MAX) NOT NULL,
    [OrgId]    VARCHAR (10)  NULL,
    [Like]     INT           NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[HistoryReceivedLineItems]...';


GO
CREATE TABLE [dbo].[HistoryReceivedLineItems] (
    [Id]                  INT             IDENTITY (1, 1) NOT NULL,
    [LineItemId]          INT             NOT NULL,
    [UpdateDate]          DATETIME        NOT NULL,
    [OldReceivedQuantity] DECIMAL (18, 3) NULL,
    [NewReceivedQuantity] DECIMAL (18, 3) NULL,
    [UserId]              VARCHAR (10)    NOT NULL,
    [CommentsUpdated]     BIT             NOT NULL,
    CONSTRAINT [PK_HistoryReceivedLineItems] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[KfsDocuments]...';


GO
CREATE TABLE [dbo].[KfsDocuments] (
    [Id]        INT          IDENTITY (1, 1) NOT NULL,
    [DocNumber] VARCHAR (50) NOT NULL,
    [OrderId]   INT          NOT NULL,
    CONSTRAINT [PK_DocumentNumbers] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[LineItems]...';


GO
CREATE TABLE [dbo].[LineItems] (
    [Id]               INT             IDENTITY (1, 1) NOT NULL,
    [Quantity]         DECIMAL (18, 3) NOT NULL,
    [QuantityReceived] DECIMAL (18, 3) NULL,
    [CatalogNumber]    VARCHAR (25)    NULL,
    [Description]      VARCHAR (MAX)   NOT NULL,
    [Unit]             VARCHAR (25)    NULL,
    [UnitPrice]        MONEY           NOT NULL,
    [Url]              VARCHAR (200)   NULL,
    [Notes]            VARCHAR (MAX)   NULL,
    [OrderId]          INT             NOT NULL,
    [CommodityId]      VARCHAR (9)     NULL,
    [Received]         AS              (CASE WHEN ([Quantity] - [QuantityReceived]) <= (0) THEN CONVERT (BIT, (1), (0)) ELSE CONVERT (BIT, (0), (0)) END) PERSISTED,
    [ReceivedNotes]    VARCHAR (MAX)   NULL,
    CONSTRAINT [PK_LineItems_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[Notifications]...';


GO
CREATE TABLE [dbo].[Notifications] (
    [Id]       UNIQUEIDENTIFIER NOT NULL,
    [UserId]   VARCHAR (10)     NOT NULL,
    [Created]  DATETIME         NOT NULL,
    [Sent]     DATETIME         NULL,
    [Status]   VARCHAR (MAX)    NULL,
    [Pending]  BIT              NOT NULL,
    [PerEvent] BIT              NOT NULL,
    [Daily]    BIT              NOT NULL,
    [Weekly]   BIT              NOT NULL,
    CONSTRAINT [PK_Notifications] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[OrderComments]...';


GO
CREATE TABLE [dbo].[OrderComments] (
    [Id]          INT           IDENTITY (1, 1) NOT NULL,
    [Text]        VARCHAR (MAX) NOT NULL,
    [DateCreated] DATETIME2 (7) NOT NULL,
    [UserId]      VARCHAR (10)  NOT NULL,
    [OrderId]     INT           NOT NULL,
    CONSTRAINT [PK_OrderComments] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[OrderRequestSaves]...';


GO
CREATE TABLE [dbo].[OrderRequestSaves] (
    [Id]           UNIQUEIDENTIFIER NOT NULL,
    [Name]         VARCHAR (150)    NOT NULL,
    [UserId]       VARCHAR (10)     NOT NULL,
    [PreparedById] VARCHAR (10)     NULL,
    [WorkgroupId]  INT              NOT NULL,
    [FormData]     VARCHAR (MAX)    NOT NULL,
    [AccountData]  VARCHAR (MAX)    NOT NULL,
    [DateCreated]  DATETIME         NOT NULL,
    [LastUpdate]   DATETIME         NOT NULL,
    [Version]      VARCHAR (15)     NULL,
    CONSTRAINT [PK_OrderRequestSaves] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[Orders]...';


GO
CREATE TABLE [dbo].[Orders] (
    [Id]                      INT           IDENTITY (1, 1) NOT NULL,
    [OrderTypeId]             CHAR (3)      NOT NULL,
    [WorkgroupVendorId]       INT           NULL,
    [WorkgroupAddressId]      INT           NOT NULL,
    [ShippingTypeId]          CHAR (2)      NULL,
    [DateNeeded]              DATETIME2 (7) NOT NULL,
    [AllowBackorder]          BIT           NOT NULL,
    [EstimatedTax]            FLOAT (53)    NULL,
    [WorkgroupId]             INT           NOT NULL,
    [OrganizationId]          VARCHAR (10)  NOT NULL,
    [ReferenceNumber]         VARCHAR (50)  NULL,
    [LastCompletedApprovalId] INT           NULL,
    [ShippingAmount]          MONEY         NULL,
    [FreightAmount]           MONEY         NULL,
    [DeliverTo]               VARCHAR (50)  NOT NULL,
    [DeliverToEmail]          VARCHAR (50)  NULL,
    [DeliverToPhone]          VARCHAR (15)  NULL,
    [Justification]           VARCHAR (MAX) NOT NULL,
    [OrderStatusCodeId]       CHAR (2)      NOT NULL,
    [CreatedBy]               VARCHAR (10)  NOT NULL,
    [DateCreated]             DATETIME      NOT NULL,
    [HasAuthorizationNum]     BIT           NOT NULL,
    [Total]                   MONEY         NOT NULL,
    [CompletionReason]        VARCHAR (MAX) NULL,
    [RequestNumber]           VARCHAR (20)  NOT NULL,
    [KfsDocType]              CHAR (3)      NULL,
    CONSTRAINT [PK_Orders_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[OrderStatusCodes]...';


GO
CREATE TABLE [dbo].[OrderStatusCodes] (
    [Id]               CHAR (2)     NOT NULL,
    [Name]             VARCHAR (50) NOT NULL,
    [Level]            INT          NULL,
    [IsComplete]       BIT          NOT NULL,
    [KfsStatus]        BIT          NOT NULL,
    [ShowInFilterList] BIT          NOT NULL,
    CONSTRAINT [PK_OrderStatusCodes] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[OrderTracking]...';


GO
CREATE TABLE [dbo].[OrderTracking] (
    [Id]                INT           IDENTITY (1, 1) NOT NULL,
    [Description]       VARCHAR (MAX) NOT NULL,
    [OrderId]           INT           NOT NULL,
    [DateCreated]       DATETIME2 (7) NOT NULL,
    [UserId]            VARCHAR (10)  NOT NULL,
    [OrderStatusCodeId] CHAR (2)      NOT NULL,
    CONSTRAINT [PK_OrderTracking_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[OrderTypes]...';


GO
CREATE TABLE [dbo].[OrderTypes] (
    [Id]                  CHAR (3)     NOT NULL,
    [Name]                VARCHAR (50) NOT NULL,
    [PurchaserAssignable] BIT          NOT NULL,
    CONSTRAINT [PK_OrderTypes] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[ParamNameAndValue]...';


GO
CREATE TABLE [dbo].[ParamNameAndValue] (
    [ParamName]   VARCHAR (255)  NOT NULL,
    [ParamValue]  VARCHAR (255)  NOT NULL,
    [Description] VARCHAR (1024) NULL,
    [IsActive]    BIT            NOT NULL,
    CONSTRAINT [PK_TableName_1] PRIMARY KEY CLUSTERED ([ParamName] ASC)
);


GO
PRINT N'Creating [dbo].[Permissions]...';


GO
CREATE TABLE [dbo].[Permissions] (
    [RoleId] CHAR (2)     NOT NULL,
    [UserId] VARCHAR (10) NOT NULL,
    CONSTRAINT [PK_Permissions] PRIMARY KEY CLUSTERED ([RoleId] ASC, [UserId] ASC)
);


GO
PRINT N'Creating [dbo].[Roles]...';


GO
CREATE TABLE [dbo].[Roles] (
    [Id]      CHAR (2)     NOT NULL,
    [Name]    VARCHAR (50) NOT NULL,
    [Level]   INT          NOT NULL,
    [IsAdmin] BIT          NOT NULL,
    CONSTRAINT [PK_RoleTypes_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ServiceMessages]...';


GO
CREATE TABLE [dbo].[ServiceMessages] (
    [Id]               INT           IDENTITY (1, 1) NOT NULL,
    [Message]          VARCHAR (MAX) NOT NULL,
    [BeginDisplayDate] DATETIME2 (7) NOT NULL,
    [EndDisplayDate]   DATETIME2 (7) NULL,
    [Critical]         BIT           NOT NULL,
    [IsActive]         BIT           NOT NULL,
    CONSTRAINT [PK_ServiceMessages] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[ShippingTypes]...';


GO
CREATE TABLE [dbo].[ShippingTypes] (
    [Id]      CHAR (2)      NOT NULL,
    [Name]    VARCHAR (50)  NOT NULL,
    [Warning] VARCHAR (MAX) NULL,
    CONSTRAINT [PK_ShippingTypes] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[Splits]...';


GO
CREATE TABLE [dbo].[Splits] (
    [Id]         INT          IDENTITY (1, 1) NOT NULL,
    [OrderId]    INT          NOT NULL,
    [LineItemId] INT          NULL,
    [Amount]     MONEY        NOT NULL,
    [Account]    VARCHAR (10) NULL,
    [SubAccount] VARCHAR (5)  NULL,
    [Project]    VARCHAR (10) NULL,
    CONSTRAINT [PK_Splits_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF)
);


GO
PRINT N'Creating [dbo].[States]...';


GO
CREATE TABLE [dbo].[States] (
    [Id]   CHAR (2)     NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_States] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[UnitOfMeasures]...';


GO
CREATE TABLE [dbo].[UnitOfMeasures] (
    [Id]   VARCHAR (4)  NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_UnitOfMeasures] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[Users]...';


GO
CREATE TABLE [dbo].[Users] (
    [Id]        VARCHAR (10) NOT NULL,
    [FirstName] VARCHAR (50) NOT NULL,
    [LastName]  VARCHAR (50) NOT NULL,
    [Email]     VARCHAR (50) NOT NULL,
    [AwayUntil] DATETIME     NULL,
    [IsActive]  BIT          NOT NULL,
    [IsAway]    AS           (isnull(CONVERT (BIT, datediff(day, [awayuntil], getdate()), 0), (0))),
    CONSTRAINT [PK_Users_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[UsersXOrganizations]...';


GO
CREATE TABLE [dbo].[UsersXOrganizations] (
    [UserId]         VARCHAR (10) NOT NULL,
    [OrganizationId] VARCHAR (10) NOT NULL,
    CONSTRAINT [PK_UsersXOrganizations] PRIMARY KEY CLUSTERED ([UserId] ASC, [OrganizationId] ASC)
);


GO
PRINT N'Creating [dbo].[vAccounts]...';


GO
CREATE TABLE [dbo].[vAccounts] (
    [Id]                      VARCHAR (10) NOT NULL,
    [Name]                    VARCHAR (50) NOT NULL,
    [IsActive]                BIT          NOT NULL,
    [AccountManager]          VARCHAR (30) NULL,
    [AccountManagerId]        VARCHAR (10) NULL,
    [PrincipalInvestigator]   VARCHAR (30) NULL,
    [PrincipalInvestigatorId] VARCHAR (10) NULL,
    [OrganizationId]          VARCHAR (10) NOT NULL,
    [PartitionColumn]         INT          NOT NULL,
    CONSTRAINT [PK_vAccounts] PRIMARY KEY CLUSTERED ([Id] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [EvenOddPartitionScheme] ([PartitionColumn])
);


GO
PRINT N'Creating [dbo].[vAccounts].[vAccounts_Id_UDX]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [vAccounts_Id_UDX]
    ON [dbo].[vAccounts]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vBuildings]...';


GO
CREATE TABLE [dbo].[vBuildings] (
    [Id]              VARCHAR (10) NOT NULL,
    [CampusCode]      VARCHAR (2)  NOT NULL,
    [BuildingCode]    VARCHAR (4)  NOT NULL,
    [CampusName]      VARCHAR (40) NULL,
    [CampusShortName] VARCHAR (12) NULL,
    [CampusTypeCode]  VARCHAR (1)  NULL,
    [BuildingName]    VARCHAR (80) NULL,
    [LastUpdateDate]  DATETIME     NULL,
    [IsActive]        BIT          NULL,
    CONSTRAINT [PK_vBuildings] PRIMARY KEY CLUSTERED ([CampusCode] ASC, [BuildingCode] ASC)
);


GO
PRINT N'Creating [dbo].[vBuildings].[vBuildings_Id_UDX]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [vBuildings_Id_UDX]
    ON [dbo].[vBuildings]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vCommodities]...';


GO
CREATE TABLE [dbo].[vCommodities] (
    [Id]              VARCHAR (9)  NOT NULL,
    [Name]            VARCHAR (60) NOT NULL,
    [GroupCode]       VARCHAR (4)  NULL,
    [SubGroupCode]    VARCHAR (2)  NULL,
    [IsActive]        BIT          NOT NULL,
    [PartitionColumn] INT          NOT NULL,
    CONSTRAINT [PK_vCommodities] PRIMARY KEY CLUSTERED ([Id] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [EvenOddPartitionScheme] ([PartitionColumn])
);


GO
PRINT N'Creating [dbo].[vCommodities].[vCommodities_Id_UDX]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [vCommodities_Id_UDX]
    ON [dbo].[vCommodities]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vCommodityGroups]...';


GO
CREATE TABLE [dbo].[vCommodityGroups] (
    [Id]           UNIQUEIDENTIFIER NOT NULL,
    [GroupCode]    VARCHAR (4)      NOT NULL,
    [Name]         VARCHAR (40)     NOT NULL,
    [SubGroupCode] VARCHAR (2)      NOT NULL,
    [SubGroupName] VARCHAR (40)     NOT NULL,
    CONSTRAINT [PK_CommodityGroups] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[vOrganizationDescendants]...';


GO
CREATE TABLE [dbo].[vOrganizationDescendants] (
    [id]                INT          IDENTITY (1, 1) NOT NULL,
    [OrgId]             VARCHAR (10) NOT NULL,
    [Name]              VARCHAR (50) NOT NULL,
    [IsActive]          BIT          NOT NULL,
    [ImmediateParentId] VARCHAR (10) NULL,
    [RollupParentId]    VARCHAR (10) NULL
);


GO
PRINT N'Creating [dbo].[vOrganizationDescendants].[vOrganizationsDescendants_OrgIdRollupParentId_IDX]...';


GO
CREATE CLUSTERED INDEX [vOrganizationsDescendants_OrgIdRollupParentId_IDX]
    ON [dbo].[vOrganizationDescendants]([OrgId] ASC, [RollupParentId] ASC);


GO
PRINT N'Creating [dbo].[vOrganizationDescendants].[PK_vOrgainzationsDescendants]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [PK_vOrgainzationsDescendants]
    ON [dbo].[vOrganizationDescendants]([id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vOrganizations]...';


GO
CREATE TABLE [dbo].[vOrganizations] (
    [Id]              VARCHAR (10) NOT NULL,
    [Name]            VARCHAR (50) NOT NULL,
    [TypeCode]        CHAR (1)     NOT NULL,
    [TypeName]        VARCHAR (50) NOT NULL,
    [ParentId]        VARCHAR (10) NULL,
    [IsActive]        BIT          NOT NULL,
    [PartitionColumn] INT          NOT NULL,
    CONSTRAINT [PK_vOrganizations] PRIMARY KEY CLUSTERED ([Id] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF)
) ON [EvenOddPartitionScheme] ([PartitionColumn]);


GO
PRINT N'Creating [dbo].[vOrganizations].[vOrganizations_Id_UDX]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [vOrganizations_Id_UDX]
    ON [dbo].[vOrganizations]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vSubAccounts]...';


GO
CREATE TABLE [dbo].[vSubAccounts] (
    [id]               UNIQUEIDENTIFIER NOT NULL,
    [AccountNumber]    VARCHAR (10)     NOT NULL,
    [SubAccountNumber] VARCHAR (5)      NOT NULL,
    [Name]             VARCHAR (40)     NULL,
    [IsActive]         BIT              NOT NULL,
    [PartitionColumn]  INT              NOT NULL,
    CONSTRAINT [PK_vSubAccounts] PRIMARY KEY CLUSTERED ([AccountNumber] ASC, [SubAccountNumber] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF)
) ON [EvenOddPartitionScheme] ([PartitionColumn]);


GO
PRINT N'Creating [dbo].[vVendorAddresses]...';


GO
CREATE TABLE [dbo].[vVendorAddresses] (
    [Id]              UNIQUEIDENTIFIER NOT NULL,
    [VendorId]        CHAR (10)        NOT NULL,
    [TypeCode]        VARCHAR (4)      NOT NULL,
    [Name]            VARCHAR (40)     NOT NULL,
    [Line1]           VARCHAR (40)     NOT NULL,
    [Line2]           VARCHAR (40)     NULL,
    [Line3]           VARCHAR (40)     NULL,
    [City]            VARCHAR (40)     NOT NULL,
    [State]           CHAR (2)         NULL,
    [Zip]             VARCHAR (11)     NULL,
    [CountryCode]     VARCHAR (2)      NULL,
    [PhoneNumber]     VARCHAR (15)     NULL,
    [FaxNumber]       VARCHAR (15)     NULL,
    [Email]           VARCHAR (50)     NULL,
    [Url]             VARCHAR (128)    NULL,
    [PartitionColumn] INT              NOT NULL,
    CONSTRAINT [PK_vVendorAddresses] PRIMARY KEY CLUSTERED ([VendorId] ASC, [TypeCode] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF)
) ON [EvenOddPartitionScheme] ([PartitionColumn]);


GO
PRINT N'Creating [dbo].[vVendors]...';


GO
CREATE TABLE [dbo].[vVendors] (
    [Id]               VARCHAR (10) NOT NULL,
    [Name]             VARCHAR (40) NOT NULL,
    [OwnershipCode]    VARCHAR (2)  NULL,
    [BusinessTypeCode] VARCHAR (2)  NULL,
    [IsActive]         BIT          NULL,
    [PartitionColumn]  INT          NOT NULL,
    CONSTRAINT [PK_vVendors] PRIMARY KEY CLUSTERED ([Id] ASC, [PartitionColumn] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF)
) ON [EvenOddPartitionScheme] ([PartitionColumn]);


GO
PRINT N'Creating [dbo].[vVendors].[vVendors_Id_UDX]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [vVendors_Id_UDX]
    ON [dbo].[vVendors]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[WorkgroupAccounts]...';


GO
CREATE TABLE [dbo].[WorkgroupAccounts] (
    [Id]                   INT          IDENTITY (1, 1) NOT NULL,
    [AccountId]            VARCHAR (10) NOT NULL,
    [WorkgroupId]          INT          NOT NULL,
    [ApproverUserId]       VARCHAR (10) NULL,
    [AccountManagerUserId] VARCHAR (10) NULL,
    [PurchaserUserId]      VARCHAR (10) NULL,
    CONSTRAINT [PK_WorkgroupAccounts] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[WorkgroupAddresses]...';


GO
CREATE TABLE [dbo].[WorkgroupAddresses] (
    [Id]           INT           IDENTITY (1, 1) NOT NULL,
    [Name]         VARCHAR (50)  NOT NULL,
    [Building]     VARCHAR (50)  NULL,
    [BuildingCode] VARCHAR (10)  NULL,
    [Room]         VARCHAR (50)  NULL,
    [Address]      VARCHAR (100) NOT NULL,
    [City]         VARCHAR (100) NOT NULL,
    [StateId]      CHAR (2)      NOT NULL,
    [Zip]          VARCHAR (10)  NOT NULL,
    [Phone]        VARCHAR (15)  NULL,
    [WorkgroupId]  INT           NOT NULL,
    [IsActive]     BIT           NOT NULL,
    CONSTRAINT [PK_WorkgroupAddresses] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[WorkgroupPermissions]...';


GO
CREATE TABLE [dbo].[WorkgroupPermissions] (
    [Id]                INT          IDENTITY (1, 1) NOT NULL,
    [WorkgroupId]       INT          NOT NULL,
    [UserId]            VARCHAR (10) NOT NULL,
    [RoleId]            CHAR (2)     NOT NULL,
    [IsAdmin]           BIT          NOT NULL,
    [ParentWorkgroupId] INT          NULL,
    CONSTRAINT [PK_WorkgroupUsers_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[Workgroups]...';


GO
CREATE TABLE [dbo].[Workgroups] (
    [Id]                        INT           IDENTITY (1, 1) NOT NULL,
    [Name]                      VARCHAR (50)  NOT NULL,
    [PrimaryOrganizationId]     VARCHAR (10)  NOT NULL,
    [IsActive]                  BIT           NOT NULL,
    [Administrative]            BIT           NOT NULL,
    [SharedOrCluster]           BIT           NOT NULL,
    [Disclaimer]                VARCHAR (MAX) NULL,
    [SyncAccounts]              BIT           NOT NULL,
    [AllowControlledSubstances] BIT           NOT NULL,
    [ForceAccountApprover]      BIT           NOT NULL,
    CONSTRAINT [PK_Workgroups_1] PRIMARY KEY NONCLUSTERED ([Id] ASC) WITH (ALLOW_PAGE_LOCKS = OFF, ALLOW_ROW_LOCKS = OFF) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[WorkgroupsXOrganizations]...';


GO
CREATE TABLE [dbo].[WorkgroupsXOrganizations] (
    [WorkgroupId]    INT          NOT NULL,
    [OrganizationId] VARCHAR (10) NOT NULL,
    CONSTRAINT [PK_WorkgroupsXOrganizations] PRIMARY KEY CLUSTERED ([WorkgroupId] ASC, [OrganizationId] ASC)
);


GO
PRINT N'Creating [dbo].[WorkgroupVendors]...';


GO
CREATE TABLE [dbo].[WorkgroupVendors] (
    [Id]                    INT           IDENTITY (1, 1) NOT NULL,
    [WorkgroupId]           INT           NOT NULL,
    [VendorId]              CHAR (10)     NULL,
    [VendorAddressTypeCode] VARCHAR (4)   NULL,
    [Name]                  VARCHAR (40)  NOT NULL,
    [Line1]                 VARCHAR (40)  NOT NULL,
    [Line2]                 VARCHAR (40)  NULL,
    [Line3]                 VARCHAR (40)  NULL,
    [City]                  VARCHAR (40)  NOT NULL,
    [State]                 CHAR (2)      NOT NULL,
    [Zip]                   VARCHAR (11)  NOT NULL,
    [CountryCode]           VARCHAR (2)   NULL,
    [IsActive]              BIT           NOT NULL,
    [Phone]                 VARCHAR (15)  NULL,
    [Fax]                   VARCHAR (15)  NULL,
    [Email]                 VARCHAR (50)  NULL,
    [Url]                   VARCHAR (128) NULL,
    CONSTRAINT [PK_WorkgroupVendors] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating DF_Approvals_Approved...';


GO
ALTER TABLE [dbo].[Approvals]
    ADD CONSTRAINT [DF_Approvals_Approved] DEFAULT ((0)) FOR [Completed];


GO
PRINT N'Creating DF_Attachments_Id...';


GO
ALTER TABLE [dbo].[Attachments]
    ADD CONSTRAINT [DF_Attachments_Id] DEFAULT (newid()) FOR [Id];


GO
PRINT N'Creating DF_Attachments_DateCreated...';


GO
ALTER TABLE [dbo].[Attachments]
    ADD CONSTRAINT [DF_Attachments_DateCreated] DEFAULT (getdate()) FOR [DateCreated];


GO
PRINT N'Creating DF_AutoApprovals_LessThan...';


GO
ALTER TABLE [dbo].[AutoApprovals]
    ADD CONSTRAINT [DF_AutoApprovals_LessThan] DEFAULT ((0)) FOR [LessThan];


GO
PRINT N'Creating DF_AutoApprovals_IsActive...';


GO
ALTER TABLE [dbo].[AutoApprovals]
    ADD CONSTRAINT [DF_AutoApprovals_IsActive] DEFAULT ((0)) FOR [IsActive];


GO
PRINT N'Creating DF_AutoApprovals_Equal...';


GO
ALTER TABLE [dbo].[AutoApprovals]
    ADD CONSTRAINT [DF_AutoApprovals_Equal] DEFAULT ((0)) FOR [Equal];


GO
PRINT N'Creating DF_ColumnPreferences_ShowOrderReceived...';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD CONSTRAINT [DF_ColumnPreferences_ShowOrderReceived] DEFAULT ((0)) FOR [ShowOrderReceived];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowRequestNumber];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowWorkgroup];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowVendor];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowCreatedBy];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowCreatedDate];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowLineItems];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowTotalAmount];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((1)) FOR [ShowStatus];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((50)) FOR [DisplayRows];


GO
PRINT N'Creating Default Constraint on [dbo].[ColumnPreferences]....';


GO
ALTER TABLE [dbo].[ColumnPreferences]
    ADD DEFAULT ((0)) FOR [ShowHasSplits];


GO
PRINT N'Creating DF_CustomFields_Order...';


GO
ALTER TABLE [dbo].[CustomFields]
    ADD CONSTRAINT [DF_CustomFields_Order] DEFAULT ((0)) FOR [Rank];


GO
PRINT N'Creating DF_CustomFields_IsRequired...';


GO
ALTER TABLE [dbo].[CustomFields]
    ADD CONSTRAINT [DF_CustomFields_IsRequired] DEFAULT ((0)) FOR [IsRequired];


GO
PRINT N'Creating DF_CustomFields_IsActive...';


GO
ALTER TABLE [dbo].[CustomFields]
    ADD CONSTRAINT [DF_CustomFields_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating DF_ELMAH_Error_ErrorId...';


GO
ALTER TABLE [dbo].[ELMAH_Error]
    ADD CONSTRAINT [DF_ELMAH_Error_ErrorId] DEFAULT (newid()) FOR [ErrorId];


GO
PRINT N'Creating DF_EmailPreferences_ApprovedOrderAssigned...';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD CONSTRAINT [DF_EmailPreferences_ApprovedOrderAssigned] DEFAULT ((1)) FOR [ApproverOrderArrive];


GO
PRINT N'Creating DF_EmailPreferences_AccountManagerOrderArrive...';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD CONSTRAINT [DF_EmailPreferences_AccountManagerOrderArrive] DEFAULT ((1)) FOR [AccountManagerOrderArrive];


GO
PRINT N'Creating DF_EmailPreferences_PurchaserOrderArrive...';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD CONSTRAINT [DF_EmailPreferences_PurchaserOrderArrive] DEFAULT ((1)) FOR [PurchaserOrderArrive];


GO
PRINT N'Creating Default Constraint on [dbo].[EmailPreferences]....';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD DEFAULT ((1)) FOR [RequesterReceived];


GO
PRINT N'Creating Default Constraint on [dbo].[EmailPreferences]....';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD DEFAULT 1 FOR [PurchaserKfsItemReceived];


GO
PRINT N'Creating Default Constraint on [dbo].[EmailPreferences]....';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD DEFAULT 1 FOR [PurchaserPCardItemReceived];


GO
PRINT N'Creating Default Constraint on [dbo].[EmailPreferences]....';


GO
ALTER TABLE [dbo].[EmailPreferences]
    ADD DEFAULT 1 FOR [PurchaserCampusServicesItemReceived];


GO
PRINT N'Creating DF_EmailQueue_Pending...';


GO
ALTER TABLE [dbo].[EmailQueue]
    ADD CONSTRAINT [DF_EmailQueue_Pending] DEFAULT ((1)) FOR [Pending];


GO
PRINT N'Creating DF_EmailQueue_DateTimeCreated...';


GO
ALTER TABLE [dbo].[EmailQueue]
    ADD CONSTRAINT [DF_EmailQueue_DateTimeCreated] DEFAULT (getdate()) FOR [DateTimeCreated];


GO
PRINT N'Creating Default Constraint on [dbo].[Faqs]....';


GO
ALTER TABLE [dbo].[Faqs]
    ADD DEFAULT 0 FOR [Like];


GO
PRINT N'Creating DF_HistoryReceivedLineItems_CommentsUpdated...';


GO
ALTER TABLE [dbo].[HistoryReceivedLineItems]
    ADD CONSTRAINT [DF_HistoryReceivedLineItems_CommentsUpdated] DEFAULT ((0)) FOR [CommentsUpdated];


GO
PRINT N'Creating DF_OrderComments_DateCreated...';


GO
ALTER TABLE [dbo].[OrderComments]
    ADD CONSTRAINT [DF_OrderComments_DateCreated] DEFAULT (getdate()) FOR [DateCreated];


GO
PRINT N'Creating DF_OrderRequestSaves_LastUpdate...';


GO
ALTER TABLE [dbo].[OrderRequestSaves]
    ADD CONSTRAINT [DF_OrderRequestSaves_LastUpdate] DEFAULT (getdate()) FOR [LastUpdate];


GO
PRINT N'Creating DF_OrderRequestSaves_Id...';


GO
ALTER TABLE [dbo].[OrderRequestSaves]
    ADD CONSTRAINT [DF_OrderRequestSaves_Id] DEFAULT (newid()) FOR [Id];


GO
PRINT N'Creating DF_OrderRequestSaves_DateCreated...';


GO
ALTER TABLE [dbo].[OrderRequestSaves]
    ADD CONSTRAINT [DF_OrderRequestSaves_DateCreated] DEFAULT (getdate()) FOR [DateCreated];


GO
PRINT N'Creating DF_Orders_Total...';


GO
ALTER TABLE [dbo].[Orders]
    ADD CONSTRAINT [DF_Orders_Total] DEFAULT ((0)) FOR [Total];


GO
PRINT N'Creating DF_Orders_HasAuthorizationNum...';


GO
ALTER TABLE [dbo].[Orders]
    ADD CONSTRAINT [DF_Orders_HasAuthorizationNum] DEFAULT ((0)) FOR [HasAuthorizationNum];


GO
PRINT N'Creating DF_OrderStatusCodes_ShowInFilterList...';


GO
ALTER TABLE [dbo].[OrderStatusCodes]
    ADD CONSTRAINT [DF_OrderStatusCodes_ShowInFilterList] DEFAULT ((1)) FOR [ShowInFilterList];


GO
PRINT N'Creating DF_OrderStatusCodes_KfsStatus...';


GO
ALTER TABLE [dbo].[OrderStatusCodes]
    ADD CONSTRAINT [DF_OrderStatusCodes_KfsStatus] DEFAULT ((0)) FOR [KfsStatus];


GO
PRINT N'Creating DF_OrderStatusCodes_IsComplete...';


GO
ALTER TABLE [dbo].[OrderStatusCodes]
    ADD CONSTRAINT [DF_OrderStatusCodes_IsComplete] DEFAULT ((0)) FOR [IsComplete];


GO
PRINT N'Creating DF__OrderTrac__DateC__3E52440B...';


GO
ALTER TABLE [dbo].[OrderTracking]
    ADD CONSTRAINT [DF__OrderTrac__DateC__3E52440B] DEFAULT (getdate()) FOR [DateCreated];


GO
PRINT N'Creating Default Constraint on [dbo].[OrderTypes]....';


GO
ALTER TABLE [dbo].[OrderTypes]
    ADD DEFAULT 0 FOR [PurchaserAssignable];


GO
PRINT N'Creating DF_ParamNameAndValue_IsActive...';


GO
ALTER TABLE [dbo].[ParamNameAndValue]
    ADD CONSTRAINT [DF_ParamNameAndValue_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating Default Constraint on [dbo].[Roles]....';


GO
ALTER TABLE [dbo].[Roles]
    ADD DEFAULT 0 FOR [IsAdmin];


GO
PRINT N'Creating DF_ServiceMessages_IsActive...';


GO
ALTER TABLE [dbo].[ServiceMessages]
    ADD CONSTRAINT [DF_ServiceMessages_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating DF_ServiceMessages_Critical...';


GO
ALTER TABLE [dbo].[ServiceMessages]
    ADD CONSTRAINT [DF_ServiceMessages_Critical] DEFAULT ((0)) FOR [Critical];


GO
PRINT N'Creating DF_ServiceMessages_BeginDisplayDate...';


GO
ALTER TABLE [dbo].[ServiceMessages]
    ADD CONSTRAINT [DF_ServiceMessages_BeginDisplayDate] DEFAULT (getdate()) FOR [BeginDisplayDate];


GO
PRINT N'Creating DF_Users_IsActive...';


GO
ALTER TABLE [dbo].[Users]
    ADD CONSTRAINT [DF_Users_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating DF_vAccounts_IsAct_22AA2996...';


GO
ALTER TABLE [dbo].[vAccounts]
    ADD CONSTRAINT [DF_vAccounts_IsAct_22AA2996] DEFAULT ((0)) FOR [IsActive];


GO
PRINT N'Creating DF_vCommodityGroups_Id...';


GO
ALTER TABLE [dbo].[vCommodityGroups]
    ADD CONSTRAINT [DF_vCommodityGroups_Id] DEFAULT (newid()) FOR [Id];


GO
PRINT N'Creating Default Constraint on [dbo].[vOrganizationDescendants]....';


GO
ALTER TABLE [dbo].[vOrganizationDescendants]
    ADD DEFAULT 1 FOR [IsActive];


GO
PRINT N'Creating DF_vSubAccounts_id...';


GO
ALTER TABLE [dbo].[vSubAccounts]
    ADD CONSTRAINT [DF_vSubAccounts_id] DEFAULT (newid()) FOR [id];


GO
PRINT N'Creating DF_vVendorAddresses_Id...';


GO
ALTER TABLE [dbo].[vVendorAddresses]
    ADD CONSTRAINT [DF_vVendorAddresses_Id] DEFAULT (newid()) FOR [Id];


GO
PRINT N'Creating DF_WorkgroupAddresses_IsActive...';


GO
ALTER TABLE [dbo].[WorkgroupAddresses]
    ADD CONSTRAINT [DF_WorkgroupAddresses_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating Default Constraint on [dbo].[WorkgroupPermissions]....';


GO
ALTER TABLE [dbo].[WorkgroupPermissions]
    ADD DEFAULT 0 FOR [IsAdmin];


GO
PRINT N'Creating DF_Workgroups_SharedOrCluster...';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD CONSTRAINT [DF_Workgroups_SharedOrCluster] DEFAULT ((0)) FOR [SharedOrCluster];


GO
PRINT N'Creating DF_Workgroups_AllowControlledSubstances...';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD CONSTRAINT [DF_Workgroups_AllowControlledSubstances] DEFAULT ((0)) FOR [AllowControlledSubstances];


GO
PRINT N'Creating DF__Workgroup__SyncA__416EA7D8...';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD CONSTRAINT [DF__Workgroup__SyncA__416EA7D8] DEFAULT ((0)) FOR [SyncAccounts];


GO
PRINT N'Creating DF__Workgroup__IsAct__239E4DCF...';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD CONSTRAINT [DF__Workgroup__IsAct__239E4DCF] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating DF__Workgroup__Admin__1AD3FDA4...';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD CONSTRAINT [DF__Workgroup__Admin__1AD3FDA4] DEFAULT ((0)) FOR [Administrative];


GO
PRINT N'Creating Default Constraint on [dbo].[Workgroups]....';


GO
ALTER TABLE [dbo].[Workgroups]
    ADD DEFAULT 0 FOR [ForceAccountApprover];


GO
PRINT N'Creating DF_WorkgroupVendors_IsActive...';


GO
ALTER TABLE [dbo].[WorkgroupVendors]
    ADD CONSTRAINT [DF_WorkgroupVendors_IsActive] DEFAULT ((1)) FOR [IsActive];


GO
PRINT N'Creating Full-text Index on [dbo].[CustomFieldAnswers]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[CustomFieldAnswers]
    ([Answer] LANGUAGE 1033)
    KEY INDEX [PK_CustomFieldAnswers]
    ON [CustomFieldAnswers_Answer_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[LineItems]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[LineItems]
    ([CatalogNumber] LANGUAGE 1033, [Description] LANGUAGE 1033, [Url] LANGUAGE 1033, [Notes] LANGUAGE 1033, [CommodityId] LANGUAGE 1033, [ReceivedNotes] LANGUAGE 1033)
    KEY INDEX [PK_LineItems_1]
    ON [LineItems_DescriptionUrlNotesCatalognumberCommoditycode_SIDX];


GO
PRINT N'Creating Full-text Index on [dbo].[OrderComments]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[OrderComments]
    ([Text] LANGUAGE 1033)
    KEY INDEX [PK_OrderComments]
    ON [OrderComments_Answer_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[Orders]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[Orders]
    ([DeliverTo] LANGUAGE 1033, [DeliverToEmail] LANGUAGE 1033, [Justification] LANGUAGE 1033, [RequestNumber] LANGUAGE 1033)
    KEY INDEX [PK_Orders_1]
    ON [Orders_justification_SIDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vAccounts]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vAccounts]
    ([Id] LANGUAGE 1033, [Name] LANGUAGE 1033)
    KEY INDEX [vAccounts_Id_UDX]
    ON [vAccounts_IdName_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vBuildings]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vBuildings]
    ([BuildingCode] LANGUAGE 1033, [BuildingName] LANGUAGE 1033)
    KEY INDEX [vBuildings_Id_UDX]
    ON [vBuildings_BuildingCodeBuildingName_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vCommodities]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vCommodities]
    ([Name] LANGUAGE 1033, [Id] LANGUAGE 1033)
    KEY INDEX [vCommodities_Id_UDX]
    ON [vCommodities_IdName_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vVendors]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vVendors]
    ([Id] LANGUAGE 1033, [Name] LANGUAGE 1033)
    KEY INDEX [vVendors_Id_UDX]
    ON [vVendors_Name_SDX];


GO
PRINT N'Creating FK_Approvals_Splits...';


GO
ALTER TABLE [dbo].[Approvals] WITH NOCHECK
    ADD CONSTRAINT [FK_Approvals_Splits] FOREIGN KEY ([SplitId]) REFERENCES [dbo].[Splits] ([Id]);


GO
PRINT N'Creating FK_Approvals_OrderStatusCodes...';


GO
ALTER TABLE [dbo].[Approvals] WITH NOCHECK
    ADD CONSTRAINT [FK_Approvals_OrderStatusCodes] FOREIGN KEY ([OrderStatusCodeId]) REFERENCES [dbo].[OrderStatusCodes] ([Id]);


GO
PRINT N'Creating FK_Attachments_Users...';


GO
ALTER TABLE [dbo].[Attachments] WITH NOCHECK
    ADD CONSTRAINT [FK_Attachments_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_Attachments_Orders...';


GO
ALTER TABLE [dbo].[Attachments] WITH NOCHECK
    ADD CONSTRAINT [FK_Attachments_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_AutoApprovals_Users1...';


GO
ALTER TABLE [dbo].[AutoApprovals] WITH NOCHECK
    ADD CONSTRAINT [FK_AutoApprovals_Users1] FOREIGN KEY ([TargetUserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_AutoApprovals_Users...';


GO
ALTER TABLE [dbo].[AutoApprovals] WITH NOCHECK
    ADD CONSTRAINT [FK_AutoApprovals_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_ConditionalApproval_vOrganizations...';


GO
ALTER TABLE [dbo].[ConditionalApproval] WITH NOCHECK
    ADD CONSTRAINT [FK_ConditionalApproval_vOrganizations] FOREIGN KEY ([OrganizationId]) REFERENCES [dbo].[vOrganizations] ([Id]);


GO
PRINT N'Creating FK_ConditionalApproval_Workgroups...';


GO
ALTER TABLE [dbo].[ConditionalApproval] WITH NOCHECK
    ADD CONSTRAINT [FK_ConditionalApproval_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_ConditionalApproval_Users...';


GO
ALTER TABLE [dbo].[ConditionalApproval] WITH NOCHECK
    ADD CONSTRAINT [FK_ConditionalApproval_Users] FOREIGN KEY ([PrimaryApproverId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_ConditionalApproval_SecondaryUser...';


GO
ALTER TABLE [dbo].[ConditionalApproval] WITH NOCHECK
    ADD CONSTRAINT [FK_ConditionalApproval_SecondaryUser] FOREIGN KEY ([SecondaryApproverId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_AuthorizationNumbers_Orders...';


GO
ALTER TABLE [dbo].[ControlledSubstanceInformation] WITH NOCHECK
    ADD CONSTRAINT [FK_AuthorizationNumbers_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_CustomFieldAnswers_Orders...';


GO
ALTER TABLE [dbo].[CustomFieldAnswers] WITH NOCHECK
    ADD CONSTRAINT [FK_CustomFieldAnswers_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_CustomFieldAnswers_CustomFields...';


GO
ALTER TABLE [dbo].[CustomFieldAnswers] WITH NOCHECK
    ADD CONSTRAINT [FK_CustomFieldAnswers_CustomFields] FOREIGN KEY ([CustomFieldId]) REFERENCES [dbo].[CustomFields] ([Id]);


GO
PRINT N'Creating FK_CustomFields_vOrganizations...';


GO
ALTER TABLE [dbo].[CustomFields] WITH NOCHECK
    ADD CONSTRAINT [FK_CustomFields_vOrganizations] FOREIGN KEY ([OrganizationId]) REFERENCES [dbo].[vOrganizations] ([Id]);


GO
PRINT N'Creating FK_EmailQueue_Users...';


GO
ALTER TABLE [dbo].[EmailQueue] WITH NOCHECK
    ADD CONSTRAINT [FK_EmailQueue_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_EmailQueue_Orders...';


GO
ALTER TABLE [dbo].[EmailQueue] WITH NOCHECK
    ADD CONSTRAINT [FK_EmailQueue_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_DocumentNumbers_Orders...';


GO
ALTER TABLE [dbo].[KfsDocuments] WITH NOCHECK
    ADD CONSTRAINT [FK_DocumentNumbers_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_LineItems_Orders...';


GO
ALTER TABLE [dbo].[LineItems] WITH NOCHECK
    ADD CONSTRAINT [FK_LineItems_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_Notifications_Users...';


GO
ALTER TABLE [dbo].[Notifications] WITH NOCHECK
    ADD CONSTRAINT [FK_Notifications_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_OrderComments_Users...';


GO
ALTER TABLE [dbo].[OrderComments] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderComments_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_OrderComments_Orders...';


GO
ALTER TABLE [dbo].[OrderComments] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderComments_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_OrderRequestSaves_Users1...';


GO
ALTER TABLE [dbo].[OrderRequestSaves] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderRequestSaves_Users1] FOREIGN KEY ([PreparedById]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_OrderRequestSaves_Users...';


GO
ALTER TABLE [dbo].[OrderRequestSaves] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderRequestSaves_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_Orders_Approvals...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_Approvals] FOREIGN KEY ([LastCompletedApprovalId]) REFERENCES [dbo].[Approvals] ([Id]);


GO
PRINT N'Creating FK_Orders_Workgroups...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_Orders_WorkgroupVendors...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_WorkgroupVendors] FOREIGN KEY ([WorkgroupVendorId]) REFERENCES [dbo].[WorkgroupVendors] ([Id]);


GO
PRINT N'Creating FK_Orders_WorkgroupAddresses...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_WorkgroupAddresses] FOREIGN KEY ([WorkgroupAddressId]) REFERENCES [dbo].[WorkgroupAddresses] ([Id]);


GO
PRINT N'Creating FK_Orders_ShippingTypes...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_ShippingTypes] FOREIGN KEY ([ShippingTypeId]) REFERENCES [dbo].[ShippingTypes] ([Id]);


GO
PRINT N'Creating FK_Orders_OrderTypes...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_OrderTypes] FOREIGN KEY ([OrderTypeId]) REFERENCES [dbo].[OrderTypes] ([Id]);


GO
PRINT N'Creating FK_Orders_OrderStatusCodes...';


GO
ALTER TABLE [dbo].[Orders] WITH NOCHECK
    ADD CONSTRAINT [FK_Orders_OrderStatusCodes] FOREIGN KEY ([OrderStatusCodeId]) REFERENCES [dbo].[OrderStatusCodes] ([Id]);


GO
PRINT N'Creating FK_OrderTracking_Users...';


GO
ALTER TABLE [dbo].[OrderTracking] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderTracking_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_OrderTracking_Orders...';


GO
ALTER TABLE [dbo].[OrderTracking] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderTracking_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_OrderTracking_OrderStatusCodes...';


GO
ALTER TABLE [dbo].[OrderTracking] WITH NOCHECK
    ADD CONSTRAINT [FK_OrderTracking_OrderStatusCodes] FOREIGN KEY ([OrderStatusCodeId]) REFERENCES [dbo].[OrderStatusCodes] ([Id]);


GO
PRINT N'Creating FK_Splits_LineItems...';


GO
ALTER TABLE [dbo].[Splits] WITH NOCHECK
    ADD CONSTRAINT [FK_Splits_LineItems] FOREIGN KEY ([LineItemId]) REFERENCES [dbo].[LineItems] ([Id]);


GO
PRINT N'Creating FK_Splits_Orders...';


GO
ALTER TABLE [dbo].[Splits] WITH NOCHECK
    ADD CONSTRAINT [FK_Splits_Orders] FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Orders] ([Id]);


GO
PRINT N'Creating FK_Splits_vAccounts...';


GO
ALTER TABLE [dbo].[Splits] WITH NOCHECK
    ADD CONSTRAINT [FK_Splits_vAccounts] FOREIGN KEY ([Account]) REFERENCES [dbo].[vAccounts] ([Id]);


GO
PRINT N'Creating FK_vAccounts_vOrganizations...';


GO
ALTER TABLE [dbo].[vAccounts] WITH NOCHECK
    ADD CONSTRAINT [FK_vAccounts_vOrganizations] FOREIGN KEY ([OrganizationId], [PartitionColumn]) REFERENCES [dbo].[vOrganizations] ([Id], [PartitionColumn]);


GO
PRINT N'Creating FK_WorkgroupAccounts_vAccounts...';


GO
ALTER TABLE [dbo].[WorkgroupAccounts] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupAccounts_vAccounts] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[vAccounts] ([Id]);


GO
PRINT N'Creating FK_WorkgroupAccounts_Workgroups...';


GO
ALTER TABLE [dbo].[WorkgroupAccounts] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupAccounts_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_WorkgroupAddresses_Workgroups...';


GO
ALTER TABLE [dbo].[WorkgroupAddresses] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupAddresses_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_WorkgroupAddresses_States...';


GO
ALTER TABLE [dbo].[WorkgroupAddresses] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupAddresses_States] FOREIGN KEY ([StateId]) REFERENCES [dbo].[States] ([Id]);


GO
PRINT N'Creating FK_WorkgroupPermissions_Workgroups...';


GO
ALTER TABLE [dbo].[WorkgroupPermissions] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupPermissions_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_WorkgroupPermissions_Users...';


GO
ALTER TABLE [dbo].[WorkgroupPermissions] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupPermissions_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[Users] ([Id]);


GO
PRINT N'Creating FK_WorkgroupPermissions_Roles...';


GO
ALTER TABLE [dbo].[WorkgroupPermissions] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupPermissions_Roles] FOREIGN KEY ([RoleId]) REFERENCES [dbo].[Roles] ([Id]);


GO
PRINT N'Creating FK_WorkgroupsXOrganizations_vOrganizations...';


GO
ALTER TABLE [dbo].[WorkgroupsXOrganizations] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupsXOrganizations_vOrganizations] FOREIGN KEY ([OrganizationId]) REFERENCES [dbo].[vOrganizations] ([Id]);


GO
PRINT N'Creating FK_WorkgroupsXOrganizations_Workgroups...';


GO
ALTER TABLE [dbo].[WorkgroupsXOrganizations] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupsXOrganizations_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating FK_WorkgroupVendors_Workgroups...';


GO
ALTER TABLE [dbo].[WorkgroupVendors] WITH NOCHECK
    ADD CONSTRAINT [FK_WorkgroupVendors_Workgroups] FOREIGN KEY ([WorkgroupId]) REFERENCES [dbo].[Workgroups] ([Id]);


GO
PRINT N'Creating [dbo].[SendEmail]...';


GO
CREATE FUNCTION [dbo].[SendEmail]
(
	@email varchar(50),
	@userid varchar(10),
	@text varchar(max)
)
RETURNS INT
AS
BEGIN
	


	return 0

END
GO
PRINT N'Creating [dbo].[udf_GetJulianDate]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 6, 2010
-- Description:	Returns the Julian date
-- Usage:
-- select dbo.udf_GetJulian(NULL) --for today's Julian date or
--
-- DECLARE @MyDate datetime = convert(datetime, '12-31-2011')
-- select dbo.udf_GetJulian(@MyDate) --for the Julian date of the date provided.
-- =============================================
CREATE FUNCTION udf_GetJulianDate 
(
	@Today datetime = NULL
)
RETURNS int
AS
BEGIN
	-- Declare the return variable here
	DECLARE @Result int
	
	IF @Today IS NULL SELECT @Today = GetDate()

	-- Add the T-SQL statements to compute the return value here
	SELECT @Result = (select datediff(d, convert(datetime,('01/01/'+convert(char(4),year(@Today)))),@Today)+1)

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Creating [dbo].[udf_GetParameterValue]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: January 12, 2012
-- Description:	Given an input parameter and a default, return the appropriate value
-- Note: Value can be disabled to force return of dafault value by setting row's IsActive bit to false.
--
-- Precedence:
-- 1. Return the @InputParamValue unless null or blank, i.e. ''
-- 2. Else return the table value unless null, blank or IsActive = false.
-- 3. Otherwise return the @DefaultValue (provided).
--
-- Usage:
-- DECLARE @AdminTableNameDefault varchar(255) = 'AdminTable'
-- DECLARE @InputParamValue varchar(255) = '' -- The value passed in by the input parameter (if present)
-- DECLARE @DefaultValue varchar(255) = (SELECT @AdminTableNameDefault) -- The default value for the parameter if not passed in or present in the [AD419].[dbo].[ParamNameAndValue] table
-- DECLARE @ParamVariableName varchar(255) = 'AdminTableName' -- The name of the variable if present in the [AD419].[dbo].[ParamNameAndValue] table
--
-- SELECT  dbo.udf_GetParameterValue (@InputParamValue, @DefaultValue, @ParamVariableName )
-- SELECT dbo.udf_GetParameterValue ('MyPassedInParamValue', 'MyDefaultParamValue', 'MyVariableName' )
-- eg. SELECT dbo.udf_GetParameterValue ('TestAdminTable', 'AdminTable', 'AdminTableName')
-- eg. SELECT dbo.udf_GetParameterValue ('TestAdminTable', 'AdminTable', 'AdminTableName' )
-- =============================================
CREATE FUNCTION udf_GetParameterValue 
(
	-- Add the parameters for the function here
	@InputParamValue varchar(255), --The value of the input parameter
	@DefaultValue varchar(255), --The default value for the parameter
	@ParamVariableName varchar(255) --The variable name of the parameter as saved in TableNameVariableName column of [AD419].[dbo].[ParameterNameAndValue]
)
RETURNS varchar(255)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @OutputParamValue varchar(255) = @InputParamValue

	-- Add the T-SQL statements to compute the return value here
	-- 1. use param if provided, else use database, else use default 
	IF @InputParamValue IS NULL OR @InputParamValue LIKE ''
	-- No param provided
		BEGIN	
		-- if table exists and value is not null of '' use table name's value
			IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ParamNameAndValue]') AND type in (N'U'))
				BEGIN
					SELECT @OutputParamValue = (SELECT ParamValue FROM [PrePurchasing].[dbo].[ParamNameAndValue] WHERE [ParamName] = @ParamVariableName AND [IsActive] = 1)
					IF (@OutputParamValue IS NULL OR @OutputParamValue LIKE '') 
						BEGIN
						-- use default:
							SELECT @OutputParamValue = @DefaultValue
						END
				-- ELSE use table name's value
				END
			ELSE
			-- use default:
				SELECT @OutputParamValue = @DefaultValue
		END
		
	-- Return the result of the function
	RETURN @OutputParamValue

END
GO
PRINT N'Creating [dbo].[udf_GetEvenOddPartitionNumber]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Get the partition number for the date provided
-- Usage: 
-- DECLARE @MyDate datetime = convert(datetime, '02-07-2012')
-- Or -- SELECT @MyDate = GetDate()
-- select dbo.udf_GetEvenOddPartitionNumber(@MyDate)
-- =============================================
CREATE FUNCTION udf_GetEvenOddPartitionNumber 
(
	-- Add the parameters for the function here
	@InputDate datetime
)
RETURNS int
AS
BEGIN
	-- Declare the return variable here
	DECLARE @Result int

	-- Add the T-SQL statements to compute the return value here
	SELECT @Result = (select dbo.udf_GetJulianDate(@InputDate)%2 + 1)

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Creating [dbo].[udf_GetAccountResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: March 01, 2012
-- Description:	Given a ContainsSearchCondition search string, 
-- return the records matching the search string provided.
--
-- Usage:
--USE [PrePurchasing]
--GO
 
--DECLARE @ContainsSearchCondition varchar(255) = '3-216 way' 
 
--SELECT * from udf_GetAccountResults(@ContainsSearchCondition)
-- results:
-- Id			Name
-- 3-SCWAWWS	WATER WAYS:WATER ED PROG FOR URBAN YOUTH
-- 3-VEN0216	VE:  VEN 216
-- L-26932UB	USDA FAS 58-3148-8-216
-- L-9226816	USDA-NRCS 74-9104-9-216
-- L-9226932	USDA FAS 58-3148-8-216
-- L-AIVU216	CA&ES:IVO:USDA58-3148-8-216-1 MONTENEGRO
-- S-IDPR829	MED: IMID: Gilead GS-US-216-0114/Pollard
-- 3-12LARA1	LARA DOWNS - 13 WAYS - 11/12 - 11/13/11
-- 3-32368UB	UCSD MCA R/CONT-216
-- 3-84629UB	Gilead Sciences award #GS-US-216-0114
-- 3-9232368	UCSD MCA R/CONT-216
-- 3-9257238	AMER HEART ASSN #96-216
-- 3-9280128	USDA 58-5348-8-216
-- 3-9284629	Gilead Sciences award #GS-US-216-0114
--
-- Modifications:
--	2012-03-02 by kjt: Revised to include filter by IsActive, TOP 20, and rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetAccountResults]
(
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	 Id varchar(10) not null
	,Name varchar(50) not null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT TOP 20
		   [Id]
		  ,[Name]
	FROM [PrePurchasing].[dbo].[vAccounts] FT_TBL INNER JOIN
	FREETEXTTABLE([vAccounts], ([Id], [Name]), @ContainsSearchCondition) KEY_TBL on FT_TBL.Id = KEY_TBL.[KEY]
	WHERE [IsActive] = 1
	ORDER BY KEY_TBL.[RANK] DESC

	RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetBuildingResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: March 13, 2012
-- Description:	Given aContainsSearchCondition search string, 
--				return the records matching the search string.
--
-- Notes: This is an example of a Multi-statement Table-valued function.   
-- This syntax behaves nicely within VS2010 database projects.  However, it requires 
-- nearly twice the number of SQL statements when compared to a similar Inline Table-valued
-- function designed for the identical purpose, plus explicit declaration of the table
-- variable beforehand.
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = '3209 test' –-Searches on either BuildingCode or BuildingName.
-- SELECT * from udf_GetBuildingResults(@ContainsSearchCondition)
-- 
-- results:
-- Id		CampusCode	BuildingCode	CampusName		CampusShortName	CampusTypeCode	BuildingName								LastUpdateDate			IsActive
-- 3-8187	3			8187			Davis Campus	Davis Campus	B				CAHFS SAN BERNARDINO DAIRY TESTING FACIL	2012-03-12 22:39:29.000	1
-- 3-3209	3			3209			Davis Campus	Davis Campus	B				GROUNDS TOOL HOUSE							2012-03-12 22:39:29.000	1
--
-- Modifications:
-- =============================================
CREATE FUNCTION [dbo].[udf_GetBuildingResults] 
(	
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	 Id varchar(10) not null
	,CampusCode varchar(2) not null
	,BuildingCode varchar(4) not null
	,CampusName varchar(40) null
	,CampusShortName varchar(12) null
	,CampusTypeCode varchar(1) null
	,BuildingName varchar(80) null
	,LastUpdateDate datetime null
	,IsActive bit null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT TOP 100 PERCENT [Id]
      ,[CampusCode]
      ,[BuildingCode]
      ,[CampusName]
      ,[CampusShortName]
      ,[CampusTypeCode]
      ,[BuildingName]
      ,[LastUpdateDate]
      ,[IsActive]
  FROM [PrePurchasing].[dbo].[vBuildings] SEARCH_TBL
  INNER JOIN FREETEXTTABLE(vBuildings, ([BuildingCode], [BuildingName]), @ContainsSearchCondition) KEY_TBL on SEARCH_TBL.Id = KEY_TBL.[KEY]
  ORDER BY KEY_TBL.[RANK] DESC

RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetCommentResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 23, 2012
-- Description:	Given an UserId (Kerberos) and ContainsSearchCondition search string, 
-- return the non-admin records matching the search string that the user can see
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = 'handle care' 
-- DECLARE @UserId varchar(255) = 'anlai' --'jsylvest'
-- 
-- SELECT * from udf_GetCommentResults(@UserId, @ContainsSearchCondition)
-- 
-- results:
-- OrderId	RequestNumber	DateCreated					Text											CreatedBy
-- 4		ACRU-DGAJOAS	2012-02-23 09:35:23.0000000	Please handle with care, these books are old	Scott Kirkland
--
-- Modifications:
--	2012-02-24 by kjt: Replaced CONTAINS with FREETEXT as per Scott Kirkland.
--	2012-02-27 by kjt: Added table alias as per Alan Lai; Revised to use alternate syntax that defines table variable first.
--	2012-03-02 by kjt: Revised to include filter rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION udf_GetCommentResults 
(	
	-- Add the parameters for the function here
	@UserId varchar(10), --User ID of currently logged in user.
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	OrderId int not null
	,RequestNumber varchar(20) not null
	,DateCreated datetime2(7) not null
	,[Text] varchar(max) not null
	,CreatedBy varchar(101) not null
)
AS
BEGIN
  INSERT INTO @returntable
  SELECT OC.[OrderId]
      ,O.[RequestNumber]
      ,OC.[DateCreated]
      ,OC.[Text]
      ,U.[FirstName] + ' ' + U.[LastName] AS [CreatedBy]
  FROM [PrePurchasing].[dbo].[OrderComments] OC
  INNER JOIN [PrePurchasing].[dbo].[Orders]	 O ON OC.[OrderId] = O.[Id]
  INNER JOIN [PrePurchasing].[dbo].[Users] U ON OC.[UserID] = U.[Id]
  INNER JOIN [PrePurchasing].[dbo].[vAccess] A ON OC.[OrderId] = A.[OrderId] 
  INNER JOIN FREETEXTTABLE([OrderComments], [text], @ContainsSearchCondition) KEY_TBL on OC.Id = KEY_TBL.[KEY]
  WHERE A.[AccessUserId] = @UserId AND A.[isadmin] = 0
  ORDER BY KEY_TBL.[RANK] DESC

  RETURN 
END
GO
PRINT N'Creating [dbo].[udf_GetCommoditiesResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 29, 2012
-- Description:	Given a ContainsSearchCondition search string, 
-- return the records matching the search string provided.
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = 'thread tap' 
-- 
-- SELECT * from udf_GetCommoditiesResults(@ContainsSearchCondition)
-- 
-- results:
-- Id	Name
-- 13114	THREAD SEALING TAPE, INCL TEFLON TAPE
-- 14208	CARBON STEEL, THREADED ROD
-- 18421	THREAD
-- 20224	SCREW, SELF-TAPPING THREAD
-- 20600	SCREW, SPECIFIED THREAD, NOT SELF-TAPPING
-- 20860	NUT/INSERT, SPECIFIED THREAD
-- 21712	SCREW, UNSPECIFIED THREAD
-- 21726	NUT, UNSPECIFIED THREAD
-- 21727	NUT, UNSPECIFIED THREAD, NOT KINDORF/SUPERSTRUT/UNISTRUT
-- 21730	INSERT OR SCREW/WASHER ASSEMBLY, UNSPECIFIED THREAD
-- 21XXX	FASTENERS, THREADED, NUTS/CREW/WASHER/INSERT,  MISCELLANEOUS
-- 27005	PLUG VALVE/COCK, NOT RATED, TWO WAY, THREADED, BRASS/BRONZE
-- 28102	PIPE FITTING, ED, IRON
-- 28110	PIPE FITTING, THREADED, IRON, UNCOATED, NOT RATED, NOT UNION
-- 28122	PIPE FITTING, THREADED, IRON, COATED INCL GALVANIZED, UNION
-- 28130	PIPE FITTING, THREADED, IRON, COATED, NOT RATED, NOT UNION
-- 28145	PIPE FITTING, THREADED, IRON, DRAINAGE, ELBOW/COUPLING
-- 28146	PIPE FITTING, THREAD, IRON, DRAINAGE, NOT ELBOW/COUPLING
-- 28160	PIPE FITTING, THREADED, CARBON STEEL, UNCOATED, UNION
-- 28180	PIPE FITTING,THREADED, CARBON STEEL, COATED INCL GALV, UNION
-- 28192	PIPE FITTING, THREADED , CARBON STEEL
-- 28200	PIPE FITTING, THREADED, ALLOY OR STAINLESS STEEL
-- 29125	PIPE FITTING, BRASS/BRONZE/COPPER, >2 THREADED ENDS,INCL TEE
-- 29404	PIPE FIT,NONFERR,WROUGHT,FEMALE THREAD, ADAPTER/UNION
-- 29405	PIPE FIT,NONFERR,WROUGHT,FEMALE THREAD, ELBOW
-- 29406	PIPE FIT,NONFERR,WROUGHT,FEMALE THREAD,TEE,NOT 29404-29405
-- 29407	PIPE FIT,NONFERR,WROUGHT,MALE THREAD, ADAPTER/UNION
-- 29408	PIPE FIT,NONFERR,WROUGHT,MALE THREAD, ELBOW
-- 29409	PIPE FIT,NONFERR,WROUGHT,MALE THREAD, TEE, NOT 29407-29408
-- 29414	PIPE FIT,NONFERR,CAST,FEMALE THREAD, ADAPTER/UNION
-- 29415	PIPE FIT,NONFERR,CAST,FEMALE THREAD, ELBOW
-- 29416	PIPE FIT,NONFERR,CAST,FEMALE THREAD, TEE, NOT 29404-29405
-- 29417	PIPE FIT,NONFERR,CAST,MALE THREAD, ADAPTER/UNION
-- 29418	PIPE FIT,NONFERR,CAST,MALE THREAD, ELBOW
-- 29419	PIPE FIT,NONFERR,CAST,MALE THREAD, TEE, NOT 29417-29418
-- 29740	PIPE FITTING, THREADED JOINTS ONLY, POLYVINYL CHLORIDE (PVC)
-- 29750	PIPE FIT, THREADED JOINTS ONLY, NOT POLYVINYL CHLORIDE (PVC)
-- 34557	ELECTRIC FITTING, SERVICE ENTRANCE, THREADED
-- 34587	ELECTRIC FITTING, SERVICE ENTRANCE, NOT THREADED
-- 34611	ELECT FIT, STRAIGHT, RIGID PIPE, THREADED, NIPPLE/ELBOW/CONN
-- 34613	ELECT FIT, STRAIGHT, RIGID PIPE, NOT THREADED, NIPPLE/ELBOW/
-- 34621	ELECT FIT, ANGLED, RIGID PIPE, THREADED, NIPPLE/ELBOW/CONN
-- 34623	ELECT FIT, ANGLED, RIGID PIPE, NOT THREADED, NIPPLE/ELBOW/CO
-- 34630	ELECT FIT, RIGID PIPE, THREADED, NOT 34611 OR 34621
-- 34636	ELECT FIT, RIGID PIPE, NOT THREADED, NOT 34613 OR 34623
-- 38410	THREAD FORMER, MACHINERY
-- 40022-55	TAPS 100G
-- 40022-56	TAPS 25G
-- 40022-57	TAPS 500G
-- 40122-70	TAPS 99% 25GR 29915-38-6
-- 55410	PUNCH/TAP/AWL/BROACH/GOUGE/REAMER, MEDICAL TOOL
-- 55810	SUTURE/THREAD, NON-STERILE, ON SPOOL, MEDICAL
--
-- Modifications:
--	2012-03-02 by kjt: Revised to include filter by IsActive, TOP 20, and rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetCommoditiesResults]
(
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	 Id varchar(9) not null
	,Name varchar(60) not null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT TOP 20 
		   [Id]
		  ,[Name]
	FROM [PrePurchasing].[dbo].[vCommodities] FT_TBL INNER JOIN
	FREETEXTTABLE([vCommodities], ([Id], [Name]), @ContainsSearchCondition) KEY_TBL on FT_TBL.Id = KEY_TBL.[KEY]
	WHERE [IsActive] = 1
	ORDER BY KEY_TBL.[RANK] DESC

RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetCustomFieldResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 23, 2012
-- Description:	Given an UserId (Kerberos) and ContainsSearchCondition search string, 
-- return the non-admin records matching the search string that the user can see
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = 'custom answer' 
-- DECLARE @UserId varchar(255) = 'anlai' --'jsylvest'
-- 
-- SELECT * from udf_GetCustomFieldResults(@UserId, @ContainsSearchCondition)
-- 
-- results:
-- OrderId	RequestNumber	Question	Answer
-- 7		ACRU-C1L5RCV	RUA #		Custom answer
--
-- Modifications:
--	2012-02-24 by kjt: Replaced CONTAINS with FREETEXT as per Scott Kirkland.
--	2012-02-27 by kjt: Added table alias as per Alan Lai; Revised to use alternate syntax that defines table variable first.
--	2012-03-02 by kjt: Revised to include filter rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetCustomFieldResults]
(
	@UserId varchar(10), --User ID of currently logged in user.
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	 OrderId int not null
	,RequestNumber varchar(20) not null
	,Question varchar(max) not null
	,Answer varchar(max) not null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT CFA.[OrderId]
      ,O.[RequestNumber]
      ,CF.[Name] AS [Question]
      ,CFA.[Answer]
	FROM [PrePurchasing].[dbo].[CustomFieldAnswers] CFA 
	INNER JOIN [PrePurchasing].[dbo].[CustomFields] CF ON CFA.[CustomFieldId] = CF.[Id]
	INNER JOIN [PrePurchasing].[dbo].[Orders]  O ON CFA.[OrderId] = O.[Id]
	INNER JOIN [PrePurchasing].[dbo].[vAccess] A ON CFA.[OrderId] = A.[OrderId] 
	INNER JOIN FREETEXTTABLE([CustomFieldAnswers], [Answer], @ContainsSearchCondition) KEY_TBL on CFA.Id = KEY_TBL.[KEY]
	WHERE A.[AccessUserId] = @UserId AND A.[isadmin] = 0 
	ORDER BY KEY_TBL.[RANK] DESC
	
	RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetLineResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 23, 2012
-- Description:	Given an UserId (Kerberos) and ContainsSearchCondition search string, 
-- return the non-admin records matching the search string that the user can see
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = 'space invades' 
-- DECLARE @UserId varchar(255) = 'anlai' --'jsylvest'
-- 
-- SELECT * from udf_GetLineResults(@UserId, @ContainsSearchCondition)
-- 
-- results:
-- OrderId	Quantity	Unit	RequestNumber	CatalogNumber	Description									Url		Notes										CommodityId
-- 4		5.000		EA		ACRU-DGAJOAS	VSD23			First Print Mark Twain Copies of Tom Sawyer	NULL	The space he invades he gets high on you	75080
-- 5		5.000		EA		ACRU-FJ6GZIL	VSD23			First Print Mark Twain Copies of Tom Sawyer	NULL	The space he invades he gets high on you	75080
-- 6		5.000		EA		ACRU-DCZDRMJ	VSD23			First Print Mark Twain Copies of Tom Sawyer	NULL	The space he invades he gets high on you	75080
--
-- Modifications:
--	2012-02-24 by kjt: Replaced CONTAINS with FREETEXT as per Scott Kirkland.
--	2012-02-27 by kjt: Added table alias as per Alan Lai; Revised to use alternate syntax that defines table variable first.
--	2012-03-02 by kjt: Revised to include filter rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetLineResults] 
(	
	-- Add the parameters for the function here
	@UserId varchar(10), --User ID of currently logged in user.
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	OrderId int not null
	,Quantity decimal(18,3) not null
	,Unit varchar(25) null
	,RequestNumber varchar(20) not null
	,CatalogNumber varchar(25) null
	,[Description] varchar(max) not null
	,Url varchar(200) null
	,Notes varchar(max) null
	,CommodityId varchar(9) null
	,ReceivedNotes varchar(max) null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT TOP 100 PERCENT LI.[OrderId]
      ,LI.[Quantity]
      ,LI.[Unit]
      ,O.[RequestNumber]
      ,LI.[CatalogNumber]
      ,LI.[Description]
      ,LI.[Url]
      ,LI.[Notes]
      ,LI.[CommodityId]
	  ,LI.[ReceivedNotes]
  FROM [PrePurchasing].[dbo].[LineItems] LI
  INNER JOIN [PrePurchasing].[dbo].[Orders]	 O ON LI.[OrderId] = O.[Id]
  INNER JOIN [PrePurchasing].[dbo].[vAccess] A ON LI.[OrderId] = A.[OrderId] 
  INNER JOIN FREETEXTTABLE([LineItems], ([Description], [Url], [Notes], [CatalogNumber], [CommodityId], [ReceivedNotes]), @ContainsSearchCondition) KEY_TBL on LI.Id = KEY_TBL.[KEY]
  WHERE A.[AccessUserId] = @UserId AND A.[isadmin] = 0 
  ORDER BY KEY_TBL.[RANK] DESC

RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetOrderResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 23, 2012
-- Description:	Given an UserId (Kerberos) and ContainsSearchCondition search string, 
-- return the non-admin records matching the search string that the user can see
--
-- Usage:
-- USE [PrePurchasing]
-- GO
-- 
-- DECLARE @ContainsSearchCondition varchar(255) = 'reading fun Smith Lai ACRU'
-- DECLARE @UserId varchar(255) = 'anlai' --'jsylvest'
-- 
-- SELECT * from udf_GetOrderResults(@UserId, @ContainsSearchCondition)
-- 
-- results:
-- Id	DateCreated				DeliverTo		DeliverToEmail		Justification					CreatedBy		RequestNumber
-- 2	2012-02-22 20:53:35.000	Alan Lai		anlai@ucdavis.edu	Justification					Alan Lai		ACRU-EFTT2H9
-- 3	2012-02-23 07:58:25.000	Frank Grimes	NULL				Justification					Frank Grimes	ACRU-FJEZEK6
-- 4	2012-02-23 09:35:22.000	Mr. Smith		msmith@ucdavis.edu	Because reading is fun-damental	Scott Kirkland	ACRU-DGAJOAS
-- 5	2012-02-23 10:33:41.000	Mr. Smith		msmith@ucdavis.edu	Because reading is fun-damental	Scott Kirkland	ACRU-FJ6GZIL
-- 6	2012-02-23 10:39:19.000	Mr. Smith		msmith@ucdavis.edu	Because reading is fun-damental	Scott Kirkland	ACRU-DCZDRMJ
-- 7	2012-02-23 11:21:04.000	Mr. Smith		msmith@ucdavis.edu	Because reading is fun-damental	Scott Kirkland	ACRU-C1L5RCV
--
-- Modifications:
--	2012-02-24 by kjt: Replaced CONTAINS with FREETEXT as per Scott Kirkland.
--	2012-02-27 by kjt: Added table name alias as per Alan Lai; Revised to use alternate syntax that defines table variable first.
--	2012-03-02 by kjt: Revised to include filter rank as per Scott Kirkland.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetOrderResults]
(	
	-- Add the parameters for the function here
	@UserId varchar(10), --User ID of currently logged in user.
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	Id int not null
	,DateCreated datetime not null
	,DeliverTo varchar(50) not null
	,DeliverToEmail varchar(50) null
	,Justification varchar(max) not null
	,CreatedBy varchar(101) not null
	,RequestNumber varchar(20) not null
)
AS
BEGIN 
  INSERT INTO @returntable
  SELECT O.[Id]
      ,O.[DateCreated]
      ,O.[DeliverTo]
      ,O.[DeliverToEmail]
      ,O.[Justification]
      ,U.[FirstName] + ' ' + U.[LastName] AS [CreatedBy]
      ,O.[RequestNumber]
  FROM [PrePurchasing].[dbo].[Orders] O
  INNER JOIN [PrePurchasing].[dbo].[Users] U ON O.[CreatedBy] = U.[Id]
  INNER JOIN [PrePurchasing].[dbo].[vAccess] A ON O.[Id] = A.[OrderId] 
  INNER JOIN FREETEXTTABLE([Orders], ([Justification], [RequestNumber], [DeliverTo], [DeliverToEmail]), @ContainsSearchCondition) KEY_TBL on O.Id = KEY_TBL.[KEY]
  WHERE A.[AccessUserId] = @UserId AND A.[isadmin] = 0 

  ORDER BY KEY_TBL.[RANK] DESC

RETURN
END
GO
PRINT N'Creating [dbo].[udf_GetVendorResults]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: March 01, 2012
-- Description:	Given a ContainsSearchCondition search string, 
-- return the records matching the search string provided.
--
-- Usage:
--USE [PrePurchasing]
--GO
 
--DECLARE @ContainsSearchCondition varchar(255) = 'General'
--
--SELECT * from udf_GetVendorResults(@ContainsSearchCondition)
-- 
-- results:
-- Id			Name
-- 0000000068	GENERAL SIGNAL POWER SYSTEMS INC
-- 0000000262	GENERAL TECHNOLOGIES
-- 0000000295	GENERAL PHYSICS CORPORATION
-- 0000000713	GENERAL PENCIL COMPANY
-- 0000000998	PROGRESSIVE PACIFIC GENERAL & ENG CONT
-- 0000001563	GENERAL GLASS & DOOR SERVICE
-- 0000001746	GENERAL GRINDING INC
-- 0000001749	GENERAL MICRO COMPANY
-- 0000002689	MCKESSON GENERAL MEDICAL
-- 0000004610	DIAMOND GENERAL DEVELOPMENT CORP
-- 0000005077	GENERAL COMPUTER SYSTEMS
-- 0000005083	GENERAL EASTERN INSTRUMENTS
-- 0000005088	GENERAL ELECTRONICS SYSTEMS INC
-- 0000005090	GENERAL HALL INC
-- 0000005093	GENERAL METERS CORPORATION
-- 0000005644	JIM REFVEM GENERAL CONTRACTOR
-- 0000006084	LANGILLS GENERAL MACHINE INC
-- 0000008360	WEST GENERAL ASSOCIATES
-- 0000008775	CHERCO GENERAL CONTRACTOR
-- 0000009624	CALIFORNIA GENERAL TIRE
--
-- Modifications:
--	2012-03-02 by kjt: Revised to include filter by TOP 20, and rank as per Scott Kirkland.
--	2012-03-21 by kjt: Added filtering where IsActive = 1 as per Alan Lai.
-- =============================================
CREATE FUNCTION [dbo].[udf_GetVendorResults]
(
	@ContainsSearchCondition varchar(255) --A string containing the word or words to search on.
)
RETURNS @returntable TABLE 
(
	 Id varchar(10) not null
	,Name varchar(40) not null
)
AS
BEGIN
	INSERT INTO @returntable
	SELECT TOP 20
		   [Id]
		  ,[Name]
	FROM [PrePurchasing].[dbo].[vVendors] FT_TBL INNER JOIN
	FREETEXTTABLE([vVendors], [Name], @ContainsSearchCondition) KEY_TBL on FT_TBL.Id = KEY_TBL.[KEY]
	WHERE [IsActive] = 1
	ORDER BY KEY_TBL.[RANK] DESC
	
	RETURN
END
GO
PRINT N'Creating [dbo].[vAdminOrgs]...';


GO
/*

	Description:

	Shows a user's rights to departments based on departmental administrative roles and their assigned orgs (performs, descendant lookup as well)

*/

CREATE VIEW [dbo].[vAdminOrgs]
	AS 

select row_number() over (order by p.userid) id, p.userid accessuserid, od.orgid, od.name, od.immediateparentid, od.rollupparentid, od.isactive
from [permissions] p 
	inner join usersxorganizations uo on uo.userid = p.userid
	inner join vorganizationdescendants od on uo.organizationid = od.rollupparentid
where p.roleid = 'DA'
GO
PRINT N'Creating [dbo].[vAdminWorkgroupRoles]...';


GO
/*

	Description:

	This query returns workgroup roles, based on administrative privileges (regardless of sharedorcluster option).

*/

CREATE VIEW [dbo].[vAdminWorkgroupRoles]
	AS 

select ROW_NUMBER() over (order by workgroups.id) id, workgroups.id adminworkgroupid, workgroups.SharedOrCluster, descendants.rollupparentid, descendants.orgid, descendantwrkgrp.id descendantworkgroupid
	, users.id userid, users.firstname + ' ' + users.lastname fullname, users.IsAway
	, roles.level rolelevel, roles.id roleid			
from workgroups
	inner join WorkgroupsXOrganizations on workgroups.id = WorkgroupsXOrganizations.workgroupid
	inner join vorganizationdescendants descendants on workgroupsxorganizations.organizationid = descendants.rollupparentid
	inner join workgroupsxorganizations descendantorgs on descendantorgs.organizationid = descendants.orgid
	inner join workgroups descendantwrkgrp on descendantwrkgrp.id = descendantorgs.workgroupid and descendantwrkgrp.administrative = 0
	inner join workgrouppermissions perms on workgroups.id = perms.workgroupid
	inner join users on perms.userid = users.id
	inner join roles on perms.roleid = roles.id
where workgroups.administrative = 1
GO
PRINT N'Creating [dbo].[vAdminWorkgroups]...';


GO
/*

	Description:

	Provides a list of workgroups, and the possible orgs that it can roll up to.  To be used i guess for associating admin workgroups to their descendant workgroups.

*/

CREATE VIEW [dbo].[vAdminWorkgroups]

	AS 

select row_number() over (order by workgroups.id) id, workgroups.id workgroupid, workgroups.name, workgroups.primaryorganizationid
	, od.rollupparentid
from workgroups
	inner join workgroupsxorganizations wo on workgroups.id = wo.workgroupid
	inner join vorganizationdescendants od on wo.organizationid = od.orgid
GO
PRINT N'Creating [dbo].[vApprovals]...';


GO
/*

	Description:

	Logic for determining when an approval goes out to the workgroup permissions.

	Conditions for workgroup permissions:
		* Approval is not conditional approval
		* Either: Primary user is not assigned or primary user is away

*/

CREATE VIEW [dbo].[vApprovals]
	AS 

select distinct approvals.id, completed, orderstatuscodeid, orderid
	, os.level
	, pusers.id primaryuserid, pusers.isaway primaryaway
	, susers.id secondaryuserid, susers.isaway secondaryaway
	, cast (case
		when orderstatuscodeid <> 'CA' and pusers.id is null then 1
		when orderstatuscodeid <> 'CA' and pusers.id is not null and pusers.isaway = 1 then 1
		else 0
	  end as bit) IsWorkgroup	
from approvals
inner join orderstatuscodes os on os.id = approvals.orderstatuscodeid
left outer join users pusers on approvals.userid = pusers.id
left outer join users susers on approvals.secondaryuserid = susers.id
GO
PRINT N'Creating [dbo].[vCommentResults]...';


GO

CREATE VIEW [dbo].[vCommentResults] WITH SCHEMABINDING
AS
SELECT     OC.Id, OC.OrderId, O.RequestNumber, OC.DateCreated, OC.Text, U.FirstName + ' ' + U.LastName AS CreatedBy
FROM         dbo.OrderComments AS OC INNER JOIN
                      dbo.Orders AS O ON OC.OrderId = O.Id INNER JOIN
                      dbo.Users AS U ON OC.UserId = U.Id
GO
PRINT N'Creating [dbo].[vCommentResults].[vCommentResults_Id_UDX]...';


GO
CREATE UNIQUE CLUSTERED INDEX [vCommentResults_Id_UDX]
    ON [dbo].[vCommentResults]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vCompletedOrdersThisMonth]...';


GO
CREATE VIEW dbo.vCompletedOrdersThisMonth
AS
SELECT     dbo.Orders.Id, dbo.Orders.OrderStatusCodeId, dbo.OrderStatusCodes.Id AS OrderStatusCodesId, dbo.OrderStatusCodes.[Level], dbo.OrderStatusCodes.IsComplete, 
                      dbo.OrderStatusCodes.KfsStatus, ot.OrderId, ot.otdatecreated, OrderTracking_1.Id AS OrderTrackingId, OrderTracking_1.Description, 
                      OrderTracking_1.OrderId AS OrderTrackingOrderId, OrderTracking_1.DateCreated AS OrderTrackingDateCreated, OrderTracking_1.UserId, 
                      OrderTracking_1.OrderStatusCodeId AS OrderTrackingOrderStatusCodeId
FROM         dbo.Orders INNER JOIN
                      dbo.OrderStatusCodes ON dbo.Orders.OrderStatusCodeId = dbo.OrderStatusCodes.Id INNER JOIN
                          (SELECT     OrderId, MAX(DateCreated) AS otdatecreated
                            FROM          dbo.OrderTracking
                            GROUP BY OrderId) AS ot ON dbo.Orders.Id = ot.OrderId INNER JOIN
                      dbo.OrderTracking AS OrderTracking_1 ON dbo.Orders.Id = OrderTracking_1.OrderId
WHERE     (dbo.OrderStatusCodes.IsComplete = 1) AND (DATEPART(Month, ot.otdatecreated) = DATEPART(Month, GETDATE()))
GO
PRINT N'Creating [dbo].[vCompletedOrdersThisWeek]...';


GO
CREATE VIEW [dbo].[vCompletedOrdersThisWeek]
AS
SELECT     dbo.Orders.Id, dbo.Orders.OrderStatusCodeId, dbo.OrderStatusCodes.Id AS OrderStatusCodesId, dbo.OrderStatusCodes.[Level], dbo.OrderStatusCodes.IsComplete, 
                      dbo.OrderStatusCodes.KfsStatus, ot.OrderId, ot.otdatecreated, OrderTracking_1.Id AS OrderTrackingId, OrderTracking_1.Description, 
                      OrderTracking_1.OrderId AS OrderTrackingOrderId, OrderTracking_1.DateCreated AS OrderTrackingDateCreated, OrderTracking_1.UserId, 
                      OrderTracking_1.OrderStatusCodeId AS OrderTrackingOrderStatusCodeId
FROM         dbo.Orders INNER JOIN
                      dbo.OrderStatusCodes ON dbo.Orders.OrderStatusCodeId = dbo.OrderStatusCodes.Id INNER JOIN
                          (SELECT     OrderId, MAX(DateCreated) AS otdatecreated
                            FROM          dbo.OrderTracking
                            GROUP BY OrderId) AS ot ON dbo.Orders.Id = ot.OrderId INNER JOIN
                      dbo.OrderTracking AS OrderTracking_1 ON dbo.Orders.Id = OrderTracking_1.OrderId
WHERE     (dbo.OrderStatusCodes.IsComplete = 1) AND (DATEPART(week, ot.otdatecreated) = DATEPART(week, GETDATE()))
GO
PRINT N'Creating [dbo].[vCustomFieldResults]...';


GO

CREATE VIEW [dbo].[vCustomFieldResults] WITH SCHEMABINDING
AS
SELECT     CFA.Id, CFA.OrderId, O.RequestNumber, CF.Name AS Question, CFA.Answer
FROM         dbo.CustomFieldAnswers AS CFA INNER JOIN
                      dbo.CustomFields AS CF ON CFA.CustomFieldId = CF.Id INNER JOIN
                      dbo.Orders AS O ON CFA.OrderId = O.Id
GO
PRINT N'Creating [dbo].[vCustomFieldResults].[vCustomFieldResults_Id_UDX]...';


GO
CREATE UNIQUE CLUSTERED INDEX [vCustomFieldResults_Id_UDX]
    ON [dbo].[vCustomFieldResults]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vEditAccess]...';


GO
/*

	Description:

	Returns a list of users who have edit access to the associated order

	Ways to have permissions:
	
		*ALL APPROVALS EXCEPT CA
		*Specified as primary user and not away
		*Primary user is away, go to workgroup permissions
		*No user defined, go to workgroup permissions
		
		*CA APPROVALS
		*Specified as primary user
		*Specified as secondary user
		

*/

CREATE VIEW [dbo].[vEditAccess]

	AS 

select ROW_NUMBER() over ( order by userid ) id, access.orderid, access.UserId accessuserid, access.IsAway, OrderStatusCodeId accesslevel
from
(
-- primary user specified, and not away
select orders.id orderid, approvals.userid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.orderstatuscodeid = os.id and approvals.completed = 0
	inner join users on users.id = approvals.userid
where approvals.userid is not null
  and os.IsComplete = 0
union
-- secondary user specified, away status doesn't matter
select orders.id orderid, approvals.secondaryuserid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.orderstatuscodeid = os.id and approvals.completed = 0
	inner join users on users.id = approvals.secondaryuserid
where secondaryuserid is not null
  and os.IsComplete = 0
union
-- workgroup permissions
select orders.id orderid, workgrouppermissions.userid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.orderstatuscodeid = os.id and approvals.completed = 0
	-- join with the workgroup
	inner join workgroups on orders.workgroupid = workgroups.id
	-- workgroup permissions
	inner join workgrouppermissions on workgroups.id = workgrouppermissions.workgroupid and orders.orderstatuscodeid = workgrouppermissions.roleid
	inner join users on users.id = WorkgroupPermissions.userid
where approvals.userid is null and approvals.secondaryuserid is null
  and os.IsComplete = 0
union
-- capture the away approvals that are not conditioanl approvals
select orders.id orderid, workgrouppermissions.userid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.orderstatuscodeid = os.id and approvals.completed = 0
	-- join with the workgroup
	inner join workgroups on orders.workgroupid = workgroups.id
	-- workgroup permissions
	inner join workgrouppermissions on workgroups.id = workgrouppermissions.workgroupid and orders.orderstatuscodeid = workgrouppermissions.roleid
	-- join for the approval user to make sure they are away
	inner join users on users.id = approvals.userid
where approvals.userid is null and approvals.secondaryuserid is null
  and users.isaway = 1
  and approvals.orderstatuscodeid <> 'CA'
  and os.IsComplete = 0
union
-- capture the conditional approvals, primary user
select orders.id orderid, approvals.userid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.completed = 0
	-- approval's status
	inner join orderstatuscodes aos on aos.id = approvals.orderstatuscodeid and aos.level = os.level
	inner join users on users.id = approvals.userid
where approvals.userid is not null
  and os.IsComplete = 0
  and approvals.orderstatuscodeid = 'CA'
union
-- capture the conditional approvals, secondary user
select orders.id orderid, approvals.secondaryuserid, users.isaway, approvals.OrderStatusCodeId
from orders
	-- order's current status
	inner join orderstatuscodes os on os.id = orders.orderstatuscodeid
	-- approvals at the same level as the order status and not completed
	inner join approvals on approvals.orderid = orders.id and approvals.completed = 0
	-- approval's status
	inner join orderstatuscodes aos on aos.id = approvals.orderstatuscodeid and aos.level = os.level
	inner join users on users.id = approvals.secondaryuserid
where approvals.secondaryuserid is not null
  and os.IsComplete = 0
  and approvals.orderstatuscodeid = 'CA'
) access
GO
PRINT N'Creating [dbo].[vLineResults]...';


GO

CREATE VIEW [dbo].[vLineResults]  WITH SCHEMABINDING
AS
SELECT     LI.Id, LI.OrderId, LI.Quantity, LI.Unit, O.RequestNumber, LI.CatalogNumber, LI.Description, LI.Url, LI.Notes, LI.CommodityId
FROM         dbo.LineItems AS LI INNER JOIN
                      dbo.Orders AS O ON LI.OrderId = O.Id
GO
PRINT N'Creating [dbo].[vOpenOrdersByUser]...';


GO
CREATE VIEW [dbo].[vOpenOrdersByUser]
	AS 

select row_number() over (order by orderid) id, *
from (
	select distinct orders.id orderid, requestnumber, orders.datecreated, dateneeded
		, creator.firstname + ' ' + creator.lastname creator
		, ordertracking.datecreated lastactiondate
		, codes.name statusname
		, lineitemsummary.summary
		, createdby accessuserid
		, wv.name VendorName
	from orders
		inner join users creator on creator.id = orders.createdby
		inner join ordertracking on orders.id = ordertracking.orderid
		inner join orderstatuscodes codes on orders.orderstatuscodeid = codes.id
		inner join ( 
			 select orderid, STUFF(
				(
					select ', ' + convert(varchar(10), a.quantity) + ' [' + a.Unit + '] ' + a.[description]
					from lineitems a
					where a.orderid = lineitems.orderid
					order by a.[description]
					for xml PATH('')
				), 1, 1, ''
			) as summary
			from lineitems
			group by orderid
		) lineitemsummary on lineitemsummary.orderid = orders.id
		left outer join WorkgroupVendors wv on orders.WorkgroupVendorId = wv.id
	where ordertracking.datecreated in ( select max(itracking.datecreated)
									from ordertracking itracking
									where ordertracking.orderid = itracking.orderid )
	  and codes.iscomplete = 0									
) OpenOrders
GO
PRINT N'Creating [dbo].[vOrderHistory]...';


GO
CREATE VIEW dbo.vOrderHistory
AS
select row_number() over (order by o.id) id, o.id orderid,  o.RequestNumber
	, w.id workgroupid, w.name workgroupname
	, case 
		when o.WorkgroupVendorId is null then '--Unspecified--'
		when o.WorkgroupVendorId is not null and wv.line1 = 'N/A' and url is null then wv.name + '(No Adddress)' 
		when o.WorkgroupVendorId is not null and wv.line1 = 'N/A' and url is not null then wv.name + '('+wv.url+')' 
		else wv.name + ' (' + wv.Line1 + ', ' + wv.City + ', ' + wv.State + ', ' +wv.Zip +  ', ' + isnull(wv.CountryCode, '') + ')'
		end Vendor
	, creator.FirstName + ' ' + creator.LastName CreatedBy
	, creator.id CreatorId
	, o.DateCreated
	, osc.id StatusId, osc.name [Status], osc.IsComplete
	, totals.totalamount 
	, lineitemsummary.summary lineitems
	, accounts.accountsubaccountsummary
	, cast(case when isnull(charindex(',', accounts.accountsubaccountsummary), 0) <> 0 then 1 else 0 end as bit) HasAccountSplit
	, o.DeliverTo ShipTo
	, case when o.AllowBackorder = 1 then 'Yes'else 'No' end AllowBackorder
	, case when o.HasAuthorizationNum = 1 then 'Yes' else 'No' end Restricted
	, o.DateNeeded
	, st.name ShippingType
	, o.ReferenceNumber
	, lastaction.DateCreated LastActionDate
	, lastaction.lastuser LastActionUser
	, case when oreceived.received = 1 then 'Yes' else 'No' end Received
	, ot.id ordertypeid, ot.name ordertype
from orders o
	inner join workgroups w on o.WorkgroupId = w.id
	left outer join WorkgroupVendors wv on o.WorkgroupVendorId = wv.id
	inner join Users creator on o.CreatedBy = creator.id
	inner join OrderStatusCodes osc on o.OrderStatusCodeId = osc.id
	left outer join ordertypes ot on ot.id = o.OrderTypeId
	inner join (
		select orderid, sum(quantity * unitprice) totalamount from LineItems group by orderid
	) totals on o.id = totals.orderid
	inner join ( 
		select orderid, STUFF(
			(
				select ', ' + convert(varchar(10), a.quantity) + ' [' + a.Unit + '] ' + a.[description]
				from lineitems a
				where a.orderid = lineitems.orderid
				order by a.[description]
				for xml PATH('')
			), 1, 1, ''
		) as summary
		from lineitems
		group by orderid
	) lineitemsummary on lineitemsummary.orderid = o.id
	inner join (
		select orderid
			, STUFF(
				(
					select ', ' + ins.Account + isnull('[' + ins.subaccount + ']', '')
					from splits ins
					where os.OrderId = ins.OrderId
					order by ins.id
					for xml PATH('')
				), 1, 1, ''
			) as accountsubaccountsummary
		from splits os
		group by os.OrderId
	) accounts on accounts.OrderId = o.id
	left outer join ShippingTypes st on o.ShippingTypeId = st.id
	left outer join (
		select rorders.id orderid, case when ireceived.received is null then 1 else 0 end received
		from orders rorders
		left outer join (	
			select distinct LineItems.orderid liorderid, 0 received
			from LineItems
			where orderid = any ( select orderid from LineItems where Received = 0) 
		) ireceived on rorders.id = ireceived.liorderid
	) oreceived on o.id = oreceived.orderid
	inner join (
		select max(oot.id) otid, oot.orderid, oot.DateCreated, users.FirstName + ' ' + users.LastName lastuser
		from ordertracking oot
		inner join (select orderid, max(datecreated) maxdatecreated from ordertracking iot group by orderid) iot
				on iot.orderid = oot.OrderId and iot.maxdatecreated = oot.DateCreated
		inner join users on oot.userid = users.id
		group by oot.orderid, oot.DateCreated, users.FirstName, users.LastName
	) lastaction on lastaction.orderid = o.id
GO
PRINT N'Creating [dbo].[vOrderPeeps]...';


GO
CREATE VIEW dbo.vOrderPeeps
AS

select ROW_NUMBER() over (order by orderid) id, orderid, workgroupid, orderstatuscodeid, userid, fullname, administrative, sharedorcluster, roleid
from (
	select orders.id orderid, orders.workgroupid, approvals.OrderStatusCodeId, wp.userid, users.firstname + ' ' + users.lastname fullname, 0 administrative, 0 sharedorcluster, wp.roleid
	from orders 
		inner join approvals on approvals.OrderId = orders.id
		inner join WorkgroupPermissions wp on orders.WorkgroupId = wp.workgroupid and approvals.OrderStatusCodeId = wp.roleid
		inner join users on wp.userid = users.id
	where approvals.UserId is null
	union
	select orders.id orderid, orders.WorkgroupId, approvals.OrderStatusCodeId, admins.userid, admins.fullname, 1 administrative, admins.SharedOrCluster, admins.roleid
	from orders
		inner join approvals on approvals.OrderId = orders.id
		inner join (
			select workgroups.id adminworkgroupid, workgroups.SharedOrCluster, descendants.rollupparentid, descendants.orgid, descendantwrkgrp.id descendantworkgroupid
				, users.id userid, users.firstname + ' ' + users.lastname fullname
				, perms.roleid
			from workgroups
				inner join WorkgroupsXOrganizations on workgroups.id = WorkgroupsXOrganizations.workgroupid
				inner join vorganizationdescendants descendants on workgroupsxorganizations.organizationid = descendants.rollupparentid
				inner join workgroupsxorganizations descendantorgs on descendantorgs.organizationid = descendants.orgid
				inner join workgroups descendantwrkgrp on descendantwrkgrp.id = descendantorgs.workgroupid and descendantwrkgrp.administrative = 0
				inner join workgrouppermissions perms on workgroups.id = perms.workgroupid
				inner join users on perms.userid = users.id
			where workgroups.administrative = 1
		) admins on orders.workgroupid = admins.descendantworkgroupid
) peeps
where orderstatuscodeid = roleid
GO
PRINT N'Creating [dbo].[vOrderResults]...';


GO


CREATE VIEW [dbo].[vOrderResults]  WITH SCHEMABINDING
AS
SELECT       O.Id, O.DateCreated, O.DeliverTo, O.DeliverToEmail, O.Justification, U.FirstName + ' ' + U.LastName AS CreatedBy, O.RequestNumber
FROM         dbo.Orders AS O INNER JOIN
                      dbo.Users AS U ON O.CreatedBy = U.Id
GO
PRINT N'Creating [dbo].[vOrderResults].[vOrderResults_Id_UDX]...';


GO
CREATE UNIQUE CLUSTERED INDEX [vOrderResults_Id_UDX]
    ON [dbo].[vOrderResults]([Id] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[vOrderTracking]...';


GO
/*
	Summary:

	Query takes the order with each user's last tracking object and provides a line item summary
	of that order.  I believe this is used to show on the landing page.

	Date :	2/16/2012
	
*/

CREATE VIEW [dbo].[vOrderTracking]
	
	AS 

select distinct ROW_NUMBER() over (order by ordertracking.orderid) id, *
from
(
	select ordertracking.datecreated TrackingDate
		, ordertracking.orderid, orders.requestnumber
		, orders.datecreated, creator.firstname + ' ' + creator.lastname createdby
		, users.Id AccessUserId
		, lineitemsummary.summary
	from users
		 inner join ordertracking on ordertracking.userid = users.id
		 inner join orders on ordertracking.orderid = orders.id
		 inner join users creator on orders.createdby = creator.id
		 inner join ( 
			 select orderid, STUFF(
				(
					select ', ' + convert(varchar(10), a.quantity) + ' [' + a.Unit + '] ' + a.[description]
					from lineitems a
					where a.orderid = lineitems.orderid
					order by a.[description]
					for xml PATH('')
				), 1, 1, ''
			) as summary
			from lineitems
			group by orderid
		 ) lineitemsummary on lineitemsummary.orderid = orders.id
	where
		 ordertracking.datecreated in ( select max(tracking.datecreated)
									from ordertracking tracking
									where ordertracking.userid = tracking.userid)
) ordertracking
GO
PRINT N'Creating [dbo].[vReadAccess]...';


GO
CREATE VIEW [dbo].[vReadAccess]

	AS 

select ROW_NUMBER() over (order by orderid) id, access.orderid, access.UserId accessuserid, access.IsAway, OrderStatusCodeId accesslevel
from
(
select distinct orderid, userid, users.IsAway, OrderStatusCodeId
from ordertracking
	inner join Users on users.Id = ordertracking.userid

union

select distinct o.id orderid, wp.userid, users.IsAway, wp.RoleId
from workgrouppermissions wp
	inner join Users on users.id = wp.UserId
	inner join Workgroups wk on wk.id = wp.WorkgroupId
	inner join orders o on o.WorkgroupId = wp.WorkgroupId
where wp.roleid = 'RV' 
  and wk.Administrative = 0

union

select distinct o.id orderid, awr.userid, users.IsAway, awr.RoleId
from vAdminWorkgroupRoles awr
	inner join users on awr.userid = users.id
	inner join orders o on awr.descendantworkgroupid = o.WorkgroupId
where awr.roleid = 'RV'
) access
GO
PRINT N'Creating [dbo].[vReportWorkload]...';


GO
CREATE VIEW [dbo].[vReportWorkload]
	AS 

select row_number() over (order by ReportingWorkgroupId) id, ReportingWorkgroupId, ReportWorkgroup, userid, users.FirstName + ' ' + users.LastName UserFullName
	, WorkgroupName, WorkgroupOrg
	, sum(Approved) Approved, sum(Edited) Edited
from (

	select distinct w.id ReportingWorkgroupId, w.name ReportWorkgroup, vaw.workgroupid, vaw.primaryorganizationid WorkgroupOrg, vaw.name WorkgroupName
		, o.id, ot.userid, ot.orderstatuscodeid
		, case  when ot.[description] like '%approve%' then 1
				when ot.[description] like '%created%' then 1
				else 0
			end Approved
		, case when ot.[description] like '%edit%' then 1
				when ot.[description] like '%rerouted%' then 1
				else 0
			end Edited
	from workgroups w
		inner join workgroupsxorganizations wo on w.id = wo.WorkgroupId
		inner join vadminworkgroups vaw on wo.organizationid = vaw.rollupparentid
		inner join orders o on o.workgroupid = vaw.workgroupid
		inner join ordertracking ot on ot.orderid = o.id
		inner join workgrouppermissions wp on w.id = wp.workgroupid and wp.userid = ot.userid
	where administrative = 1

	union

	select w.id ReportingWorkgroupId, w.name ReportingWorkgroup, w.id WorkgroupId, w.PrimaryOrganizationId WorkgroupOrg, w.Name WorkgroupName
		, o.id, ot.userid, ot.orderstatuscodeid
		, case  when ot.[description] like '%approve%' then 1
				when ot.[description] like '%created%' then 1
				else 0
			end Approved
		, case when ot.[description] like '%edit%' then 1
				when ot.[description] like '%rerouted%' then 1
				else 0
			end Edited
	from workgroups w
		inner join orders o on o.workgroupid = w.id
		inner join ordertracking ot on ot.orderid = o.id
		inner join WorkgroupPermissions wp on w.id = wp.WorkgroupId and wp.userid = ot.userid
	where administrative = 0

) TrackingHistory
	inner join users on users.id = trackinghistory.userid
group by ReportingWorkgroupId, ReportWorkgroup, WorkgroupName, WorkgroupOrg, UserId, firstname, lastname
GO
PRINT N'Creating [dbo].[vWorkgroupAdmins]...';


GO
CREATE VIEW [dbo].[vWorkgroupAdmins]
	as

select distinct ROW_NUMBER() over (order by wk.id) id
	, wk.id WorkgroupId, wk.name WorkgroupName, wk.PrimaryOrganizationId, users.id userid, users.firstname, users.lastname, users.email
from workgroups wk
	inner join vOrganizationDescendants vod on wk.PrimaryOrganizationId = vod.OrgId
	inner join UsersxOrganizations uo on vod.RollupParentId = uo.OrganizationId
	inner join users on uo.UserId = users.id
GO
PRINT N'Creating [dbo].[vWorkgroupRoles]...';


GO
CREATE VIEW [dbo].[vWorkgroupRoles]
	AS 

select row_number() over (order by workgroupid) id, workgroupid, accessuserid, roleid, isadmin
from
(
select descendantworkgroupid workgroupid, userid accessuserid, roleid, 1 isadmin
from [vAdminWorkgroupRoles]

union

select wk.id workgroupid, users.id accessuserid, roles.id roleid, 0 isadmin
from workgroups wk
	inner join workgrouppermissions perms on wk.id = perms.workgroupid
	inner join users on perms.userid = users.id
	inner join roles on perms.roleid = roles.id
where wk.Administrative = 0
) workgrouproles
GO
PRINT N'Creating [dbo].[vAdminOrderAccess]...';


GO
/*

	Description:

	This query is suppoedly suppoed to give a list of all sub-orgs that a given admin/parent that a workgroup/org might have access to.
	It also includes userid's to simplify querying and restricts orders that an admin should have access to

	Provides a list of "Pending" orders that an admin might have access to.  Readonly permissions should be derived from the ordertracking

	Updates:

		4/4/2012:	Added another query to it, so that it takes in the Shared Services or Cluster Admin workgroups.  Should give access to those special admin workgroups
					to differentiate from regular workgroups

*/

CREATE VIEW [dbo].[vAdminOrderAccess]
	
	AS 


select row_number() over (order by orderaccess.adminworkgroupid) id, orderaccess.adminworkgroupid, orderaccess.SharedOrCluster, orderaccess.OrgId
	, orderaccess.RollupParentId, orderaccess.descendantworkgroupid, orderaccess.orderid
	, orderaccess.userid accessuserid, orderaccess.IsAway
	, orderaccess.roleid
	, orderaccess.orderstatuscode
	, orderaccess.iscomplete
	, orderaccess.ispending
from
(
	/*
		Standard Administrative Workgroup Access
	*/
	select admins.*, orders.id orderid
		, cast(case when osc.Level = admins.rolelevel then 1 else 0 end as bit) ispending
		, osc.id orderstatuscode, osc.IsComplete
	from orders
	inner join (
		select adminworkgroupid, SharedOrCluster, rollupparentid, orgid, descendantworkgroupid, userid, fullname, IsAway, rolelevel, roleid	 
		from vAdminWorkgroupRoles where SharedOrCluster = 0
	) admins on orders.workgroupid = admins.descendantworkgroupid
	inner join OrderStatusCodes osc on orders.OrderStatusCodeId = osc.Id

	union

	/*
		Shared Or Cluster Administrative Workgroup Access
	*/
	select admins.*, orders.id orderid
		, cast(case when os.Level = admins.rolelevel then 1 else 0 end as bit) ispending
		, os.id orderstatuscode, os.IsComplete
	from orders
	inner join orderstatuscodes os on orders.orderstatuscodeid = os.id
	inner join vapprovals va on va.orderid = orders.id and os.level = va.level and va.isworkgroup = 1
	inner join
	(
		select adminworkgroupid, SharedOrCluster, rollupparentid, orgid, descendantworkgroupid, userid, fullname, IsAway, rolelevel, roleid	 
		from vAdminWorkgroupRoles where SharedOrCluster = 1
	) admins on orders.workgroupid = admins.descendantworkgroupid
	where os.Level = admins.rolelevel

) orderaccess
GO
PRINT N'Creating Full-text Index on [dbo].[vCommentResults]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vCommentResults]
    ([Text] LANGUAGE 1033)
    KEY INDEX [vCommentResults_Id_UDX]
    ON [OrderComments_Answer_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vCustomFieldResults]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vCustomFieldResults]
    ([Answer] LANGUAGE 1033)
    KEY INDEX [vCustomFieldResults_Id_UDX]
    ON [CustomFieldAnswers_Answer_SDX];


GO
PRINT N'Creating Full-text Index on [dbo].[vOrderResults]...';


GO
CREATE FULLTEXT INDEX ON [dbo].[vOrderResults]
    ([DeliverTo] LANGUAGE 1033, [DeliverToEmail] LANGUAGE 1033, [Justification] LANGUAGE 1033, [RequestNumber] LANGUAGE 1033)
    KEY INDEX [vOrderResults_Id_UDX]
    ON [Orders_justification_SIDX];


GO
PRINT N'Creating [dbo].[vAccess]...';


GO
CREATE VIEW [dbo].[vAccess]
	AS 

select ROW_NUMBER() over (order by orderid) id, access.orderid, access.accessuserid, access.readaccess, access.editaccess, access.isadmin, access.IsAway, accesslevel
from
	(
	-- get edit access
	select orderid, accessuserid, 1 readaccess, 1 editaccess, 0 isadmin, isaway, accesslevel
	from vEditAccess
	union
	(
	select orderid, accessuserid, 1 readaccess, ispending editaccess
		, CAST (
			case when SharedOrCluster = 1 then 0
			else 1
			end as bit ) isadmin, isaway, roleid accesslevel
	from vAdminOrderAccess
	except
	select orderid, accessuserid, 1 readaccess, 1 editaccess, 0 isadmin, isaway, accesslevel
	from vEditAccess
	)
	union
	(
	-- get user with read access not with edit access
	select orderid, accessuserid, 1 readaccess, 0 editaccess, 0 isadmin, isaway, accesslevel
	from vReadAccess
	except 
	(
		select orderid, accessuserid, 0 readaccess, ispending editaccess, 1 isadmin, 0, roleid
		from vAdminOrderAccess
		union
		select orderid, accessuserid, 1 readaccess, 0 editaccess, 0 isadmin, isaway, accesslevel
		from vEditAccess	
	)
	)
) access
GO
PRINT N'Creating [dbo].[vCommentHistory]...';


GO
CREATE VIEW dbo.vCommentHistory
AS

SELECT DISTINCT NEWID() AS id, dbo.OrderComments.OrderId, dbo.Orders.RequestNumber, dbo.Users.FirstName + ' ' + dbo.Users.LastName AS CreatedBy, 
		dbo.OrderComments.Text AS comment, dbo.OrderComments.UserId AS createdbyuserid, dbo.OrderComments.DateCreated, access.UserId AS access
FROM dbo.OrderComments 
	INNER JOIN dbo.Orders ON dbo.Orders.Id = dbo.OrderComments.OrderId 
	INNER JOIN dbo.Users ON dbo.Users.Id = dbo.OrderComments.UserId 
	INNER JOIN (
		SELECT DISTINCT OrderId, UserId
		FROM (
			select orderid, accessuserid userid
			from vaccess
			where isadmin = 0
		) AS blank
	) AS access ON access.OrderId = dbo.OrderComments.OrderId
GO
PRINT N'Creating [dbo].[vPendingOrders]...';


GO
/*
	Summary:

	Query takes the recent orders that a person needs to access.

	Date :	2/16/2012
	
*/

CREATE VIEW [dbo].[vPendingOrders]
	AS 

select row_number() over (order by pending.orderid) id, *
from 
(
	select distinct orders.id orderid, requestnumber, orders.datecreated
		, dateneeded, creator.firstname + ' ' + creator.lastname creator
		, tracking.datecreated lastactiondate
		, codes.name statusname
		, lineitemsummary.summary
		, access.accessuserid
	from orders
		inner join users creator on creator.id = orders.createdby
		inner join ordertracking tracking on tracking.orderid = orders.id
		inner join orderstatuscodes codes on orders.orderstatuscodeid = codes.id
		inner join ( 
			 select orderid, STUFF(
				(
					select ', ' + convert(varchar(10), a.quantity) + ' [' + a.Unit + '] ' + a.[description]
					from lineitems a
					where a.orderid = lineitems.orderid
					order by a.[description]
					for xml PATH('')
				), 1, 1, ''
			) as summary
			from lineitems
			group by orderid
			) lineitemsummary on lineitemsummary.orderid = orders.id
		inner join vaccess access on access.OrderId = dbo.orders.id and editaccess = 1 and isadmin = 0
	where
		tracking.datecreated in ( select max(itracking.datecreated)
								  from ordertracking itracking
								  where tracking.orderid = itracking.orderid )
		and codes.IsComplete = 0
) Pending
GO
PRINT N'Creating [dbo].[ELMAH_GetErrorsXml]...';


GO

CREATE PROCEDURE [dbo].[ELMAH_GetErrorsXml]
(
    @Application NVARCHAR(60),
    @PageIndex INT = 0,
    @PageSize INT = 15,
    @TotalCount INT OUTPUT
)
AS 

    SET NOCOUNT ON

    DECLARE @FirstTimeUTC DATETIME
    DECLARE @FirstSequence INT
    DECLARE @StartRow INT
    DECLARE @StartRowIndex INT

    SELECT 
        @TotalCount = COUNT(1) 
    FROM 
        [ELMAH_Error]
    WHERE 
        [Application] = @Application

    -- Get the ID of the first error for the requested page

    SET @StartRowIndex = @PageIndex * @PageSize + 1

    IF @StartRowIndex <= @TotalCount
    BEGIN

        SET ROWCOUNT @StartRowIndex

        SELECT  
            @FirstTimeUTC = [TimeUtc],
            @FirstSequence = [Sequence]
        FROM 
            [ELMAH_Error]
        WHERE   
            [Application] = @Application
        ORDER BY 
            [TimeUtc] DESC, 
            [Sequence] DESC

    END
    ELSE
    BEGIN

        SET @PageSize = 0

    END

    -- Now set the row count to the requested page size and get
    -- all records below it for the pertaining application.

    SET ROWCOUNT @PageSize

    SELECT 
        errorId     = [ErrorId], 
        application = [Application],
        host        = [Host], 
        type        = [Type],
        source      = [Source],
        message     = [Message],
        [user]      = [User],
        statusCode  = [StatusCode], 
        time        = CONVERT(VARCHAR(50), [TimeUtc], 126) + 'Z'
    FROM 
        [ELMAH_Error] error
    WHERE
        [Application] = @Application
    AND
        [TimeUtc] <= @FirstTimeUTC
    AND 
        [Sequence] <= @FirstSequence
    ORDER BY
        [TimeUtc] DESC, 
        [Sequence] DESC
    FOR
        XML AUTO
GO
PRINT N'Creating [dbo].[ELMAH_GetErrorXml]...';


GO

CREATE PROCEDURE [dbo].[ELMAH_GetErrorXml]
(
    @Application NVARCHAR(60),
    @ErrorId UNIQUEIDENTIFIER
)
AS

    SET NOCOUNT ON

    SELECT 
        [AllXml]
    FROM 
        [ELMAH_Error]
    WHERE
        [ErrorId] = @ErrorId
    AND
        [Application] = @Application
GO
PRINT N'Creating [dbo].[ELMAH_LogError]...';


GO

CREATE PROCEDURE [dbo].[ELMAH_LogError]
(
    @ErrorId UNIQUEIDENTIFIER,
    @Application NVARCHAR(60),
    @Host NVARCHAR(30),
    @Type NVARCHAR(100),
    @Source NVARCHAR(60),
    @Message NVARCHAR(500),
    @User NVARCHAR(50),
    @AllXml NTEXT,
    @StatusCode INT,
    @TimeUtc DATETIME
)
AS

    SET NOCOUNT ON

    INSERT
    INTO
        [ELMAH_Error]
        (
            [ErrorId],
            [Application],
            [Host],
            [Type],
            [Source],
            [Message],
            [User],
            [AllXml],
            [StatusCode],
            [TimeUtc]
        )
    VALUES
        (
            @ErrorId,
            @Application,
            @Host,
            @Type,
            @Source,
            @Message,
            @User,
            @AllXml,
            @StatusCode,
            @TimeUtc
        )
GO
PRINT N'Creating [dbo].[usp_CreateAccountsPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the vAccounts Partition Tables
-- =============================================
CREATE PROCEDURE usp_CreateAccountsPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vAccountsPartitionTable', --Default table name prefix
	@ReferentialTableNamePrefix varchar(255) = 'vOrganizationsPartitionTable', --vOrganizations table name prefix that is referenced by vAccounts table
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
DECLARE @TableNamePrefix varchar(255) = 'vAccountsPartitionTable'
DECLARE @ReferentialTableNamePrefix varchar(255) = 'vOrganizationsPartitionTable'
DECLARE @IsDebug bit = 0
*/

	SET NOCOUNT ON --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF
	DECLARE @TableNameSuffixTable TABLE (TableNameSuffix varchar(10))

	IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')

	DECLARE @TSQL varchar(MAX) = ''

	DECLARE @TableNameSuffix varchar(10) = ''
	DECLARE myCursor CURSOR FOR SELECT TableNameSuffix FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix + @TableNameSuffix + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']''))
			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] DROP CONSTRAINT [FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix + @TableNameSuffix + ']

			IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N''[DF_' + @TableNamePrefix + @TableNameSuffix + '_IsAct_22AA2996]'') AND type = ''D'')
			BEGIN
				ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] DROP CONSTRAINT [DF_' + @TableNamePrefix + @TableNameSuffix + '_IsAct_22AA2996]
			END

			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[Id] [varchar](10) NOT NULL,
				[Name] [varchar](50) NOT NULL,
				[IsActive] [bit] NOT NULL,
				[AccountManager] [varchar](30) NULL,
				[AccountManagerId] [varchar](10) NULL,
				[PrincipalInvestigator] [varchar](30) NULL,
				[PrincipalInvestigatorId] [varchar](10) NULL,
				[OrganizationId] [varchar](10) NOT NULL,
				[PartitionColumn] [int] NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED 
			(
				[Id] ASC,
				[PartitionColumn] ASC
			)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF)
			) ON EvenOddPartitionScheme (PartitionColumn)
			 
			SET ANSI_PADDING ON
		'
		IF @TableNameSuffix LIKE ''
		BEGIN
			SELECT @TSQL += '
			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']  WITH CHECK ADD  CONSTRAINT [FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix + @TableNameSuffix + '] FOREIGN KEY([OrganizationId], [PartitionColumn])
			REFERENCES [dbo].[' + @ReferentialTableNamePrefix + @TableNameSuffix + '] ([Id], [PartitionColumn])

			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] CHECK CONSTRAINT [FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix +@TableNameSuffix + '] 
		'
		END
		--ELSE IF @TableNameSuffix LIKE '_Load'
		--BEGIN
		--	SELECT @TSQL += '
		--	ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']  WITH CHECK ADD  CONSTRAINT [FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix + '] FOREIGN KEY([OrganizationId], [PartitionColumn])
		--	REFERENCES  [dbo].[' + @ReferentialTableNamePrefix + '] ([Id], [PartitionColumn])

		--	ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] CHECK CONSTRAINT [FK_' + @TableNamePrefix + @TableNameSuffix + '_' + @ReferentialTableNamePrefix + '] 
		--'
		--END
		
		SELECT @TSQL += '
			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] ADD CONSTRAINT [DF_' + @TableNamePrefix + @TableNameSuffix + '_IsAct_22AA2996]  DEFAULT ((0)) FOR [IsActive]
		'

		IF @IsDebug = 1 
			PRINT @TSQL 
		ELSE 
			EXEC(@TSQL)
			
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor
END
GO
PRINT N'Creating [dbo].[usp_CreateCommoditiesPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the Commodities Partition Tables
-- =============================================
CREATE PROCEDURE usp_CreateCommoditiesPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vCommoditiesPartitionTable', --Default table name prefix
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
DECLARE @TableNamePrefix varchar(255) = 'vCommoditiesPartitionTable'
DECLARE @IsDebug bit = 0
*/

	SET NOCOUNT ON --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF
	DECLARE @TableNameSuffixTable TABLE (TableNameSuffix varchar(10))
    IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')

	DECLARE @TSQL varchar(MAX) = ''

	DECLARE @TableNameSuffix varchar(10) = ''
	DECLARE myCursor CURSOR FOR SELECT TableNameSuffix FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[Id] [varchar](9) NOT NULL,
				[Name] [varchar](60) NOT NULL,
				[GroupCode] [varchar](4)  NULL,
				[SubGroupCode] [varchar](2)  NULL,
				[IsActive] [bit] NOT NULL,
				[PartitionColumn] INT NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED
			(
				[Id] ASC,
				[PartitionColumn] ASC
			) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF))
			ON EvenOddPartitionScheme (PartitionColumn)

			SET ANSI_PADDING ON

			EXEC sys.sp_addextendedproperty @name=N''MS_Description'', @value=N''Commodity_num/Commodity_code'' , @level0type=N''SCHEMA'',@level0name=N''dbo'', @level1type=N''TABLE'',@level1name=N'''+ @TableNamePrefix + @TableNameSuffix +''', @level2type=N''COLUMN'',@level2name=N''Id''
	'

		IF @IsDebug = 1 
			PRINT @TSQL 
		ELSE 
			EXEC(@TSQL)
			
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor
END
GO
PRINT N'Creating [dbo].[usp_CreateOrganizationsPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the vOrganizations Partition Tables
-- =============================================
CREATE PROCEDURE usp_CreateOrganizationsPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vOrganizationsPartitionTable', --Default vOrganizations table name prefix
	@ReferentialTableNamePrefix varchar(255) = 'vAccountsPartitionTable', --vAccounts table name prefix that references vOrganizations table
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
	DECLARE @TableNamePrefix varchar(255) = 'vOrganizationsPartitionTable'
	DECLARE @ReferentialTableNamePrefix varchar(255) = 'vAccountsPartitionTable'
	DECLARE @IsDebug bit = 0
*/
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;  --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF

	DECLARE @TableNameSuffixTable TABLE (TableName varchar(255))
	IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')
	DECLARE @TSQL varchar(MAX) = ''
	DECLARE @TableNameSuffix varchar(10) = '' 

	DECLARE myCursor CURSOR FOR SELECT TableName FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 

		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialTableNamePrefix + @TableNameSuffix +'_' + @TableNamePrefix + @TableNameSuffix  + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialTableNamePrefix + @TableNameSuffix + ']''))
			BEGIN
				ALTER TABLE [PrePurchasing].[dbo].['+ @ReferentialTableNamePrefix + @TableNameSuffix+ '] DROP CONSTRAINT [FK_' + @ReferentialTableNamePrefix + @TableNameSuffix +'_' + @TableNamePrefix + @TableNameSuffix + ']
			END

			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[Id] [varchar](10) NOT NULL,
				[Name] [varchar](50) NOT NULL,
				[TypeCode] [char](1) NOT NULL,
				[TypeName] [varchar](50) NOT NULL,
				[ParentId] [varchar](10) NULL,
				[IsActive] [bit] NOT NULL,
				[PartitionColumn] [int] NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED
			(
				[Id] ASC, [PartitionColumn] ASC
			) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF))
			ON EvenOddPartitionScheme (PartitionColumn)

			SET ANSI_PADDING ON
		'

		IF @IsDebug = 1 PRINT @TSQL ELSE EXEC(@TSQL)
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor	
END
GO
PRINT N'Creating [dbo].[usp_CreateSubAccountsPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the SubAccounts Partition Tables
-- =============================================
CREATE PROCEDURE usp_CreateSubAccountsPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vSubAccountsPartitionTable', --Default table name prefix
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
DECLARE @TableNamePrefix varchar(255) = 'vSubAccountsPartitionTable'
DECLARE @IsDebug bit = 0
*/

	SET NOCOUNT ON --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF
	DECLARE @TableNameSuffixTable TABLE (TableNameSuffix varchar(10))
	IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')
		
	DECLARE @TSQL varchar(MAX) = ''

	DECLARE @TableNameSuffix varchar(10) = ''
	DECLARE myCursor CURSOR FOR SELECT TableNameSuffix FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N''[DF_' + @TableNamePrefix + @TableNameSuffix + '_id]'') AND type = ''D'')
			BEGIN
				ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] DROP CONSTRAINT [DF_' + @TableNamePrefix + @TableNameSuffix + '_id]
			END

			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[id] [uniqueidentifier] NOT NULL,
				[AccountNumber] [varchar](10) NOT NULL,
				[SubAccountNumber] [varchar](5) NOT NULL,
				[Name] [varchar](40) NULL,
				[IsActive] [bit] NOT NULL,
				[PartitionColumn] INT NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED
			(
				[AccountNumber] ASC,
				[SubAccountNumber] ASC,
				[PartitionColumn] ASC
			) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF))
			ON EvenOddPartitionScheme (PartitionColumn)

			SET ANSI_PADDING ON

			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] ADD  CONSTRAINT [DF_' + @TableNamePrefix + @TableNameSuffix + '_id]  DEFAULT (newid()) FOR [id]	
		'

		IF @IsDebug = 1 
			PRINT @TSQL 
		ELSE 
			EXEC(@TSQL)
			
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor
END
GO
PRINT N'Creating [dbo].[usp_CreateVendorAddressesPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the VendorAddresses Partition Tables
-- =============================================
CREATE PROCEDURE usp_CreateVendorAddressesPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vVendorAddressesPartitionTable', --Default table name prefix
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
	DECLARE @TableNamePrefix varchar(255) = 'vVendorAddressesPartitionTable'
	DECLARE @IsDebug bit = 0
*/
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;  --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF
	
	DECLARE @TableNameSuffixTable TABLE (TableName varchar(255))
	IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')
		
	DECLARE @TSQL varchar(MAX) = ''
	DECLARE @TableNameSuffix varchar(10) = '' 

	DECLARE myCursor CURSOR FOR SELECT TableName FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[Id] [uniqueidentifier] NOT NULL,
				[VendorId] [char](10) NOT NULL,
				[TypeCode] [varchar](4) NOT NULL,
				[Name] [varchar](40)  NOT NULL,
				[Line1] [varchar](40) NOT NULL,
				[Line2] [varchar](40) NULL,
				[Line3] [varchar](40) NULL,
				[City] [varchar](40)  NOT NULL,
				[State] [char](2) NULL,
				[Zip] [varchar](11)  NULL,
				[CountryCode] [varchar](2) NULL,
				[PhoneNumber] [varchar](15) NULL,
				[FaxNumber] [varchar](15) NULL,
				[Email] [varchar](50) NULL,
				[Url] [varchar](128) NULL,
				[PartitionColumn] [int] NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED
			(
				[VendorId] ASC,
				[TypeCode] ASC,
				[PartitionColumn] ASC
			) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF))
			ON EvenOddPartitionScheme (PartitionColumn)

			SET ANSI_PADDING ON

			ALTER TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '] ADD  CONSTRAINT [DF_' + @TableNamePrefix + @TableNameSuffix + '_Id]  DEFAULT (newid()) FOR [Id]
		'
		
		IF @IsDebug = 1 PRINT @TSQL ELSE EXEC(@TSQL)
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor
END
GO
PRINT N'Creating [dbo].[usp_CreateVendorsPartitionTable]...';


GO

-- =============================================
-- Author:		Ken Taylor
-- Create date: February 8, 2012
-- Description:	Create the Vendors Partition Tables
-- Modifications: 
--	2012-03-21 by kjt: Added IsActive bit as per Alan Lai.
-- =============================================
CREATE PROCEDURE usp_CreateVendorsPartitionTable
	-- Add the parameters for the stored procedure here
	@TableNamePrefix varchar(255) = 'vVendorsPartitionTable', --Default table name prefix
	@Mode smallint = 1, --0 to create all three tables; 1 to create main table only (default); 2 to create load tables only.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
/*
DECLARE @TableNamePrefix varchar(255) = 'vVendorsPartitionTable'
DECLARE @IsDebug bit = 0
*/

	SET NOCOUNT ON --Keeps from displaying (3 row(s) affected) message after inserting table names into @TableNameTable.
	--SET NOCOUNT OFF
	DECLARE @TableNameSuffixTable TABLE (TableNameSuffix varchar(10))
    
    IF @Mode = 1
		INSERT INTO @TableNameSuffixTable VALUES ('')
	ELSE IF @Mode = 2
		INSERT INTO @TableNameSuffixTable VALUES ('_Load'), ('_Empty')
	ELSE
		INSERT INTO @TableNameSuffixTable VALUES (''), ('_Load'), ('_Empty')
	
	DECLARE @TSQL varchar(MAX) = ''

	DECLARE @TableNameSuffix varchar(10) = ''
	DECLARE myCursor CURSOR FOR SELECT TableNameSuffix FROM @TableNameSuffixTable

	OPEN myCursor

	FETCH NEXT FROM myCursor INTO @TableNameSuffix

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		SELECT @TSQL = '
			IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableNamePrefix + @TableNameSuffix + ']'') AND type in (N''U''))
			BEGIN
				DROP TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + ']
			END

			SET ANSI_NULLS ON

			SET QUOTED_IDENTIFIER ON

			SET ANSI_PADDING ON

			CREATE TABLE [dbo].[' + @TableNamePrefix + @TableNameSuffix + '](
				[Id] [varchar](10) NOT NULL,
				[Name] [varchar](40) NOT NULL,
				[OwnershipCode] [varchar](2) NULL,
				[BusinessTypeCode] [varchar](2) NULL,
				[IsActive] [bit] NULL,
				[PartitionColumn] INT NOT NULL,
				CONSTRAINT [PK_' + @TableNamePrefix + @TableNameSuffix + '] PRIMARY KEY CLUSTERED
			(
				[Id] ASC,
				[PartitionColumn] ASC
			) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = OFF, ALLOW_PAGE_LOCKS  = OFF))
			ON EvenOddPartitionScheme (PartitionColumn)

			SET ANSI_PADDING ON
	'

		IF @IsDebug = 1 
			PRINT @TSQL 
		ELSE 
			EXEC(@TSQL)
			
		FETCH NEXT FROM myCursor INTO @TableNameSuffix
	END

	CLOSE myCursor
	DEALLOCATE myCursor
END
GO
PRINT N'Creating [dbo].[usp_DownloadAccountsPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download account data and ultimately load into the vAccountsPartitionTable
-- Modifications:
--	2012-02-16 by kjt: Removed post-loading Organizations FK creation logic and made its
-- own separate sproc because that portion would fail if accounts table contained the prior day's data in
-- the other partition.
-- =============================================
CREATE PROCEDURE [dbo].[usp_DownloadAccountsPartitionTable]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vAccountsPartitionTable', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = 'vOrganizationsPartitionTable', --Name of Organizations table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
	INSERT INTO ' + @LoadTableName + ' SELECT 
       [Id]
      ,[Name]
      ,  (CASE WHEN (ExpirationDate IS NOT NULL AND ExpirationDate <= GETDATE()) THEN 0
		  ELSE 1 END) AS [IsActive]
      ,[AccountManager]
      ,[AccountManagerId]
      ,[PrincipalInvestigator]
      ,[PrincipalInvestigatorId]
      ,[OrganizationId]
      , ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT 
			A.CHART_NUM || ''''-'''' || A.ACCT_NUM AS Id,
			A.ACCT_NAME AS Name,
			A.acct_expiration_date AS ExpirationDate,
			A.ACCT_MGR_NAME AS AccountManager,
			A.ACCT_MGR_ID AS AccountManagerId,
			A.PRINCIPAL_INVESTIGATOR_NAME AS PrincipalInvestigator,
			A.PRINCIPAL_INVESTIGATOR_ID AS PrincipalInvestigatorId,
			A.CHART_NUM || ''''-'''' || A.ORG_ID AS OrganizationId
		FROM FINANCE.ORGANIZATION_ACCOUNT A
		WHERE A.FISCAL_YEAR = 9999 AND A.FISCAL_PERIOD = ''''--'''' 
		AND A.ORG_ID IS NOT NULL
	'')
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadBuildingsTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 22, 2012
-- Description:	Download Campus Buildings data and ultimately load into the vBuildings table.
-- Modifications: 2012-03-12 by kjt: Added Id field as per Alan Lai.
-- =============================================
CREATE PROCEDURE [dbo].[usp_DownloadBuildingsTable]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vBuildings', --Name of table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column, N/A in this case
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
    
merge ' + @LoadTableName + '  as ' + @LoadTableName + ' 
using
(
	SELECT
		 campus_code + ''-'' + building_code as [Id]
		,campus_code AS [CampusCode]
		,building_code AS [BuildingCode]
		,campus_name AS [CampusName]
		,campus_short_name AS [CampusShortName]
		,campus_type_code AS [CampusTypeCode]
		,building_name AS [BuildingName]
		,ds_last_update_date AS [LastUpdateDate]
		,(CASE active_ind WHEN ''Y'' THEN 1
						  WHEN ''N'' THEN 0
	      END) AS [IsActive]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT
			campus_code,
			building_code,
			campus_name,
			campus_short_name,
			campus_type_code,
			building_name,
			ds_last_update_date,
			active_ind 			
		FROM FINANCE.CAMPUS_BUILDING
	'')
) ' + @LinkedServerName + '_' + @LoadTableName + ' ON ' + @LoadTableName + '.CampusCode   = ' + @LinkedServerName + '_' + @LoadTableName + '.CampusCode AND
					   ' + @LoadTableName + '.BuildingCode = ' + @LinkedServerName + '_' + @LoadTableName + '.BuildingCode

WHEN MATCHED THEN UPDATE set
	' + @LoadTableName + '.[CampusName] = ' + @LinkedServerName + '_' + @LoadTableName + '.[CampusName],
	' + @LoadTableName + '.[CampusShortName] = ' + @LinkedServerName + '_' + @LoadTableName + '.[CampusShortName],
	' + @LoadTableName + '.[CampusTypeCode] = ' + @LinkedServerName + '_' + @LoadTableName + '.[CampusTypeCode],
	' + @LoadTableName + '.[BuildingName] = ' + @LinkedServerName + '_' + @LoadTableName + '.[BuildingName],
	' + @LoadTableName + '.[LastUpdateDate] = ' + @LinkedServerName + '_' + @LoadTableName + '.[LastUpdateDate],
	' + @LoadTableName + '.[IsActive] = ' + @LinkedServerName + '_' + @LoadTableName + '.[IsActive]

WHEN NOT MATCHED BY TARGET THEN INSERT VALUES 
 (	 [Id]
	,[CampusCode]
	,[BuildingCode]
	,[CampusName]
	,[CampusShortName]
	,[CampusTypeCode]
	,[BuildingName]
	,[LastUpdateDate]
	,[IsActive]
 )
--WHEN NOT MATCHED BY SOURCE THEN DELETE
;'
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadCommoditiesPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download Commodities data and ultimately load into the vCommoditiesPartitionTable
-- =============================================
CREATE PROCEDURE usp_DownloadCommoditiesPartitionTable
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vCommoditiesPartitionTable_Load', --Name of load table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
	INSERT INTO ' + @LoadTableName + ' 
	SELECT
		[Id]
		,[Name]	
		,[GroupCode]
		,[SubGroupCode]
		,(CASE [IsActive] WHEN ''Y'' THEN 1 ELSE 0 END) AS [IsActive]
      , ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT
			commodity_num AS Id,
			commodity_desc AS Name,
			commodity_group_code AS GroupCode,
			commodity_sub_group_code AS SubGroupCode,
			active_ind  AS IsActive
		FROM FINANCE.COMMODITY
	'')'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadOrganizationsPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download organizational data and ultimately load into the vOrganizationsPartitionTable
-- =============================================
CREATE PROCEDURE [dbo].[usp_DownloadOrganizationsPartitionTable]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vOrganizationsPartitionTable_Load', --Load table name, i.e. prefix, of load table being loaded 
	@ReferentialTableName varchar(244) = 'vAccountsPartitionTable', --Name of accounts table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @ReferentialLoadTableName varchar(255) = @ReferentialTableName + '_Load'
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialLoadTableName + '_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialLoadTableName + ']''))
		ALTER TABLE [PrePurchasing].[dbo].[' + @ReferentialLoadTableName + '] DROP CONSTRAINT [FK_' + @ReferentialLoadTableName + '_' + @TableName + ']

	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
--	ALTER TABLE [dbo].[' + @ReferentialLoadTableName + ']  WITH CHECK ADD  CONSTRAINT [FK_' + @ReferentialLoadTableName + '_' + @TableName + '] FOREIGN KEY([OrganizationId], [PartitionColumn])
--REFERENCES [dbo].[' + @TableName + '] ([Id], [PartitionColumn])
--	ALTER TABLE [dbo].[' + @ReferentialLoadTableName + '] CHECK CONSTRAINT [FK_' + @ReferentialLoadTableName + '_' + @TableName + '] 
	
	INSERT INTO ' + @LoadTableName + ' SELECT DISTINCT
		[Id]
		,ISNULL ([Name], [Id]) AS [Name]
		,[TypeCode]
		,[TypeName]
		,[ParentId]
		,(CASE [IsActive] WHEN ''Y'' THEN 1 ELSE 0 END) AS [IsActive]
      , ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT DISTINCT
			O.CHART_NUM || ''''-'''' || O.ORG_ID AS Id,
			O.ORG_NAME AS Name,
			O.ORG_TYPE_CODE AS TypeCode,
			O.org_type_name AS TypeName,
			O.CHART_NUM || ''''-'''' || O.rpts_to_org_id AS ParentId,
			O.ACTIVE_IND AS IsActive
		FROM FINANCE.ORGANIZATION_HIERARCHY O
		WHERE O.FISCAL_YEAR = 9999 AND O.FISCAL_PERIOD = ''''--'''' 
	'')
	
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialLoadTableName + '_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialLoadTableName + ']''))
		ALTER TABLE [dbo].[' + @ReferentialLoadTableName + '] DROP CONSTRAINT [FK_' + @ReferentialLoadTableName + '_' + @TableName + ']

	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialTableName + '_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialTableName + ']''))
		ALTER TABLE [dbo].[' + @ReferentialTableName + '] DROP CONSTRAINT [FK_' + @ReferentialTableName + '_' + @TableName + ']
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadSubAccountsPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download sub-accounts data and ultimately load into the vSubAccountsPartitionTable
-- =============================================
CREATE PROCEDURE usp_DownloadSubAccountsPartitionTable
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vSubAccountsPartitionTable_Load', --Name of load table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
	INSERT INTO ' + @LoadTableName + ' (AccountNumber, SubAccountNumber, Name, IsActive, PartitionColumn)
	SELECT DISTINCT
		[AccountNumber]
		,[SubAccountNumber]
		,[Name]
		,(CASE [IsActive] WHEN ''Y'' THEN 1 ELSE 0 END) AS [IsActive]
      , ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT DISTINCT
			S.CHART_NUM || ''''-'''' || S.acct_num AS AccountNumber,
			S.sub_acct_num AS SubAccountNumber,
			S.sub_acct_name  AS Name,
			S.sub_acct_active_ind  AS IsActive
		FROM FINANCE.SUB_ACCOUNT S
		WHERE S.FISCAL_YEAR = 9999 AND S.FISCAL_PERIOD = ''''--'''' 
	'')'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadUnitOfMeasuresTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 22, 2012
-- Description:	Download UnitOfMeasure data and ultimately load into the UnitOfMeasures table
-- =============================================
CREATE PROCEDURE [dbo].[usp_DownloadUnitOfMeasuresTable]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'UnitOfMeasures', --Name of table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column, N/A in this case
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
    
merge ' + @LoadTableName + '  as ' + @LoadTableName + ' 
using
(
	SELECT
		 [Id]
		,[Name]	
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT
			unit_of_measure_code AS Id,
			unit_of_measure_name AS Name
			
		FROM FINANCE.AR_UNIT_OF_MEASURE
	'')
) ' + @LinkedServerName + '_' + @LoadTableName + ' ON ' + @LoadTableName + '.Id = ' + @LinkedServerName + '_' + @LoadTableName + '.Id

WHEN MATCHED THEN UPDATE set
	' + @LoadTableName + '.Name = ' + @LinkedServerName + '_' + @LoadTableName + '.Name
WHEN NOT MATCHED BY TARGET THEN INSERT VALUES 
 (
	 Id
	,Name
 )
--WHEN NOT MATCHED BY SOURCE THEN DELETE
;'
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadVendorAddressesPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download VendorAddresses data and ultimately load into the vVendorAddressesPartitionTable
-- =============================================
CREATE PROCEDURE usp_DownloadVendorAddressesPartitionTable
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vVendorAddressesPartitionTable_Load', --Name of load table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
	INSERT INTO ' + @LoadTableName + ' (
		[VendorId],
		[TypeCode],
		[Name],
		[Line1],
		[Line2],
		[Line3],
		[City],
		[State],
		[Zip],
		[CountryCode],
		[PhoneNumber],
		[FaxNumber],
		[Email], [Url],
		[PartitionColumn])
	SELECT
		[VendorId],
		[TypeCode],
		[Name],
		[Line1],
		[Line2],
		[Line3],
		[City],
		[State],
		[Zip],
		[CountryCode],
		[PhoneNumber], [FaxNumber],
		[Email_ID], [Web_Id],
       ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT
			vendor_id AS VendorId,
			address_type_code AS TypeCode,
			address_name  AS Name,
			address_line_1 Line1,
			address_line_2 Line2,
			address_line_3 Line3,
			city_name City,
			state_code State,
			zip_code Zip,
			country_code CountryCode ,
			phone_number PhoneNumber,
			fax_number FaxNumber,
			email_id, web_id
		FROM FINANCE.VENDOR_ADDRESS
		WHERE address_name IS NOT NULL
	'')'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_DownloadVendorsPartitionTable]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Download Vendors data and ultimately load into the vVendorsPartitionTable
-- Modifications: 
--	2012-03-21 by kjt: Added IsActive bit as per Alan Lai.
-- =============================================
CREATE PROCEDURE usp_DownloadVendorsPartitionTable
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vVendorsPartitionTable_Load', --Name of load table being loaded 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	TRUNCATE TABLE [PrePurchasing].[dbo].[' + @LoadTableName + ']
	
	INSERT INTO ' + @LoadTableName + ' 
	SELECT
		 [Id]
		,[Name]	
		,[OwnershipCode]
		,[BusinessTypeCode]
		,(CASE WHEN VendorInactiveDate <= GETDATE() THEN 0
		  ELSE 1 END) AS [IsActive]
      , ' + Convert(char(1), @PartitionColumn) + ' AS [PartitionColumn]
	FROM 
	OPENQUERY(' + @LinkedServerName + ', ''
		SELECT
			vendor_id AS Id,
			vendor_name  AS Name,
			vendor_ownership_code  AS OwnershipCode,
			business_type_code AS BusinessTypeCode,
			vendor_inactive_date AS VendorInactiveDate
		FROM FINANCE.VENDOR
		WHERE vendor_name IS NOT NULL
	'')'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_LoadAllPrePurchasingTables]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 14, 2012
-- Description:	Load all of the new PrePurchasing tables as per Alan Lai
-- Note: 
--		Comment out specific rows in @ParamsTable table to alter which tables are loaded.
--		Change TableName and ReferentialTableName fields in @ParamsTable table to alter names of tables being loaded.
--
-- Usage:
--	USE [PrePurchasing]
--	GO
--
--	DECLARE	@return_value int
-- 
--	EXEC	@return_value = [dbo].[usp_LoadAllPrePurchasingTables] [@LinkedServerName = <some_other_linked_server>] [@IsDebug = 1]
-- 
--	SELECT	'Return Value' = @return_value
-- 
--	GO
--
-- Modifications:
--	2012-02-16 by kjt: Revised to call accounts post load processing sproc.
--  2012-02-22 by kjt: Revised to allow calling of pre-processing sproc.
--	2012-02-23 by kjt: Revised main loop ELSE portion to pass @TableName Vs. @LoadTableName.
--	2012-02-28 by kjt: Revised @LinkedServerName from varchar(10) to varchar(20) to allow for longer server names.
--	2012-02-29 by kjt: Revised to include pre and post scripts for vCommodities.
--	2012-03-01 by kjt: Revised to include pre and post processing script for vVendors
--	2012-03-09 by kjt: Revised to call load sproc for vBuildings as per Alan Lai.
-- =============================================
CREATE PROCEDURE usp_LoadAllPrePurchasingTables 
	-- Add the parameters for the stored procedure here
	@LinkedServerName varchar(20) = '', --Can be changed to whatever the 'full' access linked server connection is. 
	@IsDebug bit = 0 --Set to 1 to display SQL statements
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
/*
	DECLARE @LinkedServerName varchar(10) = 'FIS_DS'
    DECLARE @IsDebug bit = 0
*/
	DECLARE	@ReturnVal int
	DECLARE @TableCount int = 0
	DECLARE @SQL_String nvarchar(MAX) = N''
	
	SELECT @LinkedServerName = (SELECT dbo.udf_GetParameterValue(@LinkedServerName, 'FIS_DS', 'LinkedServerName'))

	DECLARE @ParamsTable TABLE (LoadSprocName varchar(255), PreProcessingSprocName varchar(255), PostProcessingSprocName varchar (255), CreateTableSprocName varchar(255), TableName varchar(255), ReferentialTableName varchar(255))
	
	INSERT INTO @ParamsTable VALUES 
		 ('usp_DownloadOrganizationsPartitionTable', 'usp_Pre_DownloadOrganizationsPartitionTable_Processing', 'usp_Post_DownloadOrganizationsPartitionTable_Processing', 'usp_CreateOrganizationsPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vOrganizations', 'OrganizationsTableName')), (SELECT dbo.udf_GetParameterValue(NULL, 'vAccounts', 'AccountsTableName')))
		,('usp_DownloadAccountsPartitionTable', 'usp_Pre_DownloadAccountsPartitionTable_Processing', 'usp_Post_DownloadAccountsPartitionTable_Processing', 'usp_CreateAccountsPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vAccounts', 'AccountsTableName')), (SELECT dbo.udf_GetParameterValue(NULL, 'vOrganizations', 'OrganizationsTableName')))
		,('usp_DownloadSubAccountsPartitionTable', '', '', 'usp_CreateSubAccountsPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vSubAccounts', 'SubAccountsTableName')), '')
		,('usp_DownloadCommoditiesPartitionTable', 'usp_Pre_DownloadCommoditiesPartitionTable_Processing', 'usp_Post_DownloadCommoditiesPartitionTable_Processing', 'usp_CreateCommoditiesPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vCommodities', 'CommoditiesTableName')), '')
		,('usp_DownloadVendorsPartitionTable', 'usp_Pre_DownloadVendorsPartitionTable_Processing', 'usp_Post_DownloadVendorsPartitionTable_Processing', 'usp_CreateVendorsPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vVendors', 'VendorsTableName')), '')
		,('usp_DownloadVendorAddressesPartitionTable', '', '', 'usp_CreateVendorAddressesPartitionTable', (SELECT dbo.udf_GetParameterValue(NULL, 'vVendorAddresses', 'VendorAddressesTableName')), '')
		,('usp_DownloadUnitOfMeasuresTable', '', '', '', (SELECT dbo.udf_GetParameterValue(NULL, 'UnitOfMeasures', 'UnitOfMeasuresTableName')), '')
		,('usp_DownloadBuildingsTable', '', '', '', (SELECT dbo.udf_GetParameterValue(NULL, 'vBuildings', 'BuildingsTableName')), '')
		
	IF @IsDebug = 1 
	BEGIN
		SELECT 'Linked Server Name: ' + @LinkedServerName
		SELECT * FROM @ParamsTable
	END
	
	DECLARE @LoadSprocName varchar(255), @PreProcessingSprocName varchar (255), @PostProcessingSprocName varchar (255), @CreateTableSprocName varchar(255), @TableName varchar(255), @ReferentialTableName varchar(255)

	DECLARE @Parameter_Definition nvarchar(MAX) = N'
		@LoadSprocName varchar(255),
		@CreateTableSprocName varchar(255), 
		@TableName varchar(255), 
		@ReferentialTableName varchar(255), 
		@LinkedServerName varchar(20), 
		@IsDebug bit, 
		@return_value int OUTPUT'
		
	DECLARE LoadCursor CURSOR FOR SELECT * FROM @ParamsTable
	OPEN LoadCursor 
	FETCH NEXT FROM LoadCursor INTO @LoadSprocName, @PreProcessingSprocName, @PostProcessingSprocName, @CreateTableSprocName, @TableName, @ReferentialTableName 
	WHILE @@FETCH_STATUS <> -1
	BEGIN
		DECLARE @LoadTableName varchar(255) = @TableName + '_Load' 
		DECLARE @PartitionColumn int = (SELECT dbo.udf_GetEvenOddPartitionNumber(GETDATE()))
	
		IF @PreProcessingSprocName IS NOT NULL AND @PreProcessingSprocName NOT LIKE ''
		BEGIN
			SELECT @SQL_String = N'
				EXEC @return_value = 
				[dbo].[' + @PreProcessingSprocName + ']
					@LoadTableName,
					@ReferentialTableName,
					@LinkedServerName,
					@PartitionColumn,
					@IsDebug;
		'
			EXECUTE sp_executesql @SQL_String, N'
				@LoadTableName varchar(255), 
				@ReferentialTableName varchar(255), 
				@LinkedServerName varchar(20), 
				@PartitionColumn int, 
				@IsDebug bit, 
				@return_value int OUTPUT', 
				@LoadTableName = @LoadTableName, 
				@ReferentialTableName = @ReferentialTableName,
				@LinkedServerName = @LinkedServerName, 
				@PartitionColumn = @PartitionColumn,
				@IsDebug = @IsDebug, 
				@return_value = @ReturnVal OUTPUT
			
			-- SELECT	'Return Value' = @ReturnVal
		END
	
		IF @CreateTableSprocName IS NOT NULL AND @CreateTableSprocName NOT LIKE ''
		  BEGIN
		  -- Handle swap-table loads:
			SELECT @SQL_String = N'
			EXEC @return_value = 
			[dbo].[usp_LoadTableUsingSwapPartitions]
				@LoadSprocName,
				@CreateTableSprocName,
				@TableName,
				@ReferentialTableName,
				@LinkedServerName,
				@IsDebug;
		'
			EXECUTE sp_executesql @SQL_String, @Parameter_Definition, 
			@LoadSprocName = @LoadSprocName, 
			@CreateTableSprocName = @CreateTableSprocName, 
			@TableName = @TableName, 
			@ReferentialTableName = @ReferentialTableName,
			@LinkedServerName = @LinkedServerName, 
			@IsDebug = @IsDebug, 
			@return_value = @ReturnVal OUTPUT
			
			-- SELECT	'Return Value' = @ReturnVal
		  END
		ELSE
		  BEGIN
		  -- Handle non-swap table loads:
		  	DECLARE @StartTime datetime = (SELECT GETDATE())
			DECLARE @TempTime datetime = (SELECT @StartTime)
			DECLARE @EndTime datetime = (SELECT @StartTime)
			IF @IsDebug = 0 PRINT '--Start time for loading ' + @LoadTableName + ': ' +  + CONVERT(varchar(20),@StartTime, 114)

			SELECT @SQL_String = N'
				EXEC @return_value = 
				[dbo].[' + @LoadSprocName + ']
					@LoadTableName,
					@LinkedServerName,
					@PartitionColumn,
					@IsDebug;
		'
		
			EXECUTE sp_executesql @SQL_String, N'
				@LoadTableName varchar(255), 
				@LinkedServerName varchar(20), 
				@PartitionColumn int, 
				@IsDebug bit, 
				@return_value int OUTPUT', 
				@LoadTableName = @TableName, 
				@LinkedServerName = @LinkedServerName, 
				@PartitionColumn = @PartitionColumn,
				@IsDebug = @IsDebug, 
				@return_value = @ReturnVal OUTPUT
			
			-- SELECT	'Return Value' = @ReturnVal
			
			SELECT @StartTime = (@TempTime)
			SELECT @EndTime = (GETDATE())	
			IF @IsDebug = 0 PRINT '--Execution time for loading ' + @LoadTableName + ': ' + CONVERT(varchar(20),@EndTime - @StartTime, 114)
			
		  END
		
		IF @PostProcessingSprocName IS NOT NULL AND @PostProcessingSprocName NOT LIKE ''
		BEGIN
			SELECT @SQL_String = N'
				EXEC @return_value = 
				[dbo].[' + @PostProcessingSprocName + ']
					@LoadTableName,
					@ReferentialTableName,
					@LinkedServerName,
					@PartitionColumn,
					@IsDebug;
		'
			
			EXECUTE sp_executesql @SQL_String, N'
				@LoadTableName varchar(255), 
				@ReferentialTableName varchar(255), 
				@LinkedServerName varchar(20), 
				@PartitionColumn int, 
				@IsDebug bit, 
				@return_value int OUTPUT', 
				@LoadTableName = @LoadTableName, 
				@ReferentialTableName = @ReferentialTableName,
				@LinkedServerName = @LinkedServerName, 
				@PartitionColumn = @PartitionColumn,
				@IsDebug = @IsDebug, 
				@return_value = @ReturnVal OUTPUT
			
			-- SELECT	'Return Value' = @ReturnVal
		END
		
		IF @IsDebug = 0
			BEGIN
				SELECT @SQL_String = N'SELECT @Count = (SELECT count(*) FROM ' + @TableName + ')'
				EXECUTE sp_executesql @SQL_String, N'@Count int OUTPUT', @Count = @TableCount OUTPUT
			
				SELECT @TableName + ': ' + CONVERT(varchar(10), @TableCount) AS [Record Count] 
			END
			
		FETCH NEXT FROM LoadCursor INTO @LoadSprocName, @PreProcessingSprocName, @PostProcessingSprocName, @CreateTableSprocName, @TableName, @ReferentialTableName 
	END

	CLOSE LoadCursor
	DEALLOCATE LoadCursor
END
GO
PRINT N'Creating [dbo].[usp_LoadTableUsingSwapPartitions]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 7, 2012
-- Description:	Call a table's load procedure to load a partitioned "load" table 
-- and then swap the entire partition to the main table.
-- Modifications:
-- 2012-02-22 by kjt: Added to only print timing statements is @IsDebug = 0
-- =============================================
CREATE PROCEDURE [dbo].[usp_LoadTableUsingSwapPartitions] 
	@LoadSprocName varchar(255) = 'usp_DownloadAccountsPartitionTable', --Name of sproc that loads data from Campus FIS database.
	@CreateTableSprocName varchar(255) = 'usp_CreateAccountsPartitionTable', --Name of sproc that that creates the load and empty partition tables.
	@TableName varchar(255) = 'vAccountsPartitionTable', --Can be passed another table name, i.e. #vAccountsPartitionTable, etc.
	@ReferentialTableName varchar(255) = '', --Can be passed a referental table name, i.e. vAccountsPartitionTable, etc. Typically blank except when loading vOrganizations... OR vAccounts
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.  This allows to use something other than 'FIS_DS' if needed. 
	@IsDebug bit = 0 -- Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	DECLARE @MyDate datetime = GetDate()
	
	DECLARE @DestinationTableName varchar(255) = @TableName 
	
	DECLARE @LoadTableName varchar(255) = @DestinationTableName + '_Load'
	
	DECLARE @ReferentialLoadTableName varchar(255) = @ReferentialTableName + '_Load'

	DECLARE @EmptyTableName varchar(255) = @DestinationTableName + '_Empty'
	
	DECLARE @PartnNum smallint = (select dbo.udf_GetEvenOddPartitionNumber(@MyDate))
	DECLARE @OldPartnNum smallint = (SELECT dbo.udf_GetEvenOddPartitionNumber(DATEADD(d, -1, @MyDate)))

	
	DECLARE @TSQL varchar(MAX) = ''
		
	DECLARE @StartTime datetime = (SELECT GETDATE())
	DECLARE @TempTime datetime = (SELECT @StartTime)
	DECLARE @EndTime datetime = (SELECT @StartTime)
	IF @IsDebug = 0 PRINT '--Start time for loading ' + @LoadTableName + ' using swap partitions: ' +  + CONVERT(varchar(20),@StartTime, 114)
	
	-- Create the main table if it does not already exist:
	IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[' + @TableName + ']') AND type in (N'U'))
	BEGIN
		SELECT @TSQL = 'EXEC [dbo].[' + @CreateTableSprocName + '] 
		@TableNamePrefix = ' + @TableName + ', '
		IF @ReferentialTableName IS NOT NULL AND @ReferentialTableName NOT LIKE ''
			SELECT @TSQL += '@ReferentialTableNamePrefix = ' + @ReferentialTableName + ', ' 
		SELECT @TSQL += '
		@Mode = 1, 
		@IsDebug = ' + convert(varchar(1), @IsDebug) + ''	
	END
	
	SELECT @TSQL += '
	EXEC [dbo].[' + @CreateTableSprocName + '] 
		@TableNamePrefix = ' + @TableName + ', '
		IF @ReferentialTableName IS NOT NULL AND @ReferentialTableName NOT LIKE ''
			SELECT @TSQL += '@ReferentialTableNamePrefix = ' + @ReferentialTableName + ', ' 
	SELECT @TSQL += '
		@Mode = 2, 
		@IsDebug = ' + convert(varchar(1), @IsDebug) + '
		
	EXEC ' + @LoadSprocName + ' 
		@LoadTableName = ' + @LoadTableName + ', '
		IF @ReferentialTableName IS NOT NULL AND @ReferentialTableName NOT LIKE ''
			SELECT @TSQL += '@ReferentialTableName = ' + @ReferentialTableName + ', ' 
		SELECT @TSQL += '
		@LinkedServerName = ' + @LinkedServerName + ', 
		@PartitionColumn = ' + convert(char(1),@PartnNum) + ', 
		@IsDebug = ' + convert(varchar(1), @IsDebug) 
    IF @IsDebug = 1 
    BEGIN 
		EXEC (@TSQL) 
		SELECT @TSQL = ''
	END
	PRINT '--' + @TableName + '''s new partition number is ' + CONVERT(char(1),@PartnNum)
	
		-- Note that the receiving partition MUST be empty.
		-- Therefore, 
		-- Swap the tables's old partition's record set with an empty one from Tablename's _Empty table
		SELECT @TSQL += '
	ALTER TABLE ' + @DestinationTableName + 
'
	SWITCH PARTITION ' + CONVERT(char(1),@PartnNum) + ' TO ' + @EmptyTableName + ' PARTITION ' + CONVERT(char(1),@PartnNum)
	SELECT @TSQL += '
	ALTER TABLE ' + @DestinationTableName + 
'
	SWITCH PARTITION ' + CONVERT(char(1),@OldPartnNum) + ' TO ' + @EmptyTableName + ' PARTITION ' + CONVERT(char(1),@OldPartnNum)
	 
		-- Swap the Tablename's _Load partition's record set with the newly empty one from Tablename
		SELECT @TSQL += '
	ALTER TABLE ' + @LoadTableName + 
'
	SWITCH PARTITION ' + CONVERT(char(1),@PartnNum) + ' TO ' + @DestinationTableName + ' PARTITION ' + CONVERT(char(1),@PartnNum)
		 
	SELECT @TSQL += '
	TRUNCATE TABLE ' + @EmptyTableName
	
	SELECT @TSQL += '
	DROP TABLE ' + @LoadTableName + '
	DROP TABLE ' + @EmptyTableName
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END

	SELECT @StartTime = (@TempTime)
	
	SELECT @EndTime = (GETDATE())
	
	
	IF @IsDebug = 0 PRINT '--Execution time for loading ' + @LoadTableName + ' using swap partitions: ' + CONVERT(varchar(20),@EndTime - @StartTime, 114)
	
END
GO
PRINT N'Creating [dbo].[usp_Post_DownloadAccountsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 16, 2012
-- Description:	Restoring Organizations FK after downloading account data and swapping with load table.
-- Modifications: 2012-03-01 by kjt: Revised to include statements necessary to recreate full-text search catalog and indexes
-- =============================================
CREATE PROCEDURE [dbo].[usp_Post_DownloadAccountsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vAccounts_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = 'vOrganizations', --Name of Organizations table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	-- This is where the issue is: --------------------------
	-- Before we can switch today''s load table partition with today''s main table partition, we have to handle
	-- the load table''s FK reference/constraint against the Organizations table.
	-- Normally this would be against the Organizations load table; however, this is not possible since the Organizations load
	-- table does not exist; therefore, we create the FK against the main organizations table instead, and this technique seems
	-- to work and allow us to swap partitions:
	
	IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
	BEGIN
		CREATE UNIQUE NONCLUSTERED INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] 
		(
			[Id] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	END

	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_Splits_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[Splits]''))
	BEGIN
		ALTER TABLE [dbo].[Splits]  WITH CHECK ADD  CONSTRAINT [FK_Splits_' + @TableName + '] FOREIGN KEY([Account])
			REFERENCES [dbo].[' + @TableName + '] ([Id])
			
		ALTER TABLE [dbo].[Splits] CHECK CONSTRAINT [FK_Splits_' + @TableName + ']
	END
	
	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_WorkgroupAccounts_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[WorkgroupAccounts]''))
	BEGIN
		ALTER TABLE [dbo].[WorkgroupAccounts]  WITH CHECK ADD  CONSTRAINT [FK_WorkgroupAccounts_' + @TableName + '] FOREIGN KEY([AccountId])
			REFERENCES [dbo].[' + @TableName + '] ([Id])
		
		ALTER TABLE [dbo].[WorkgroupAccounts] CHECK CONSTRAINT [FK_WorkgroupAccounts_' + @TableName + ']
	END
	
	-- Do the same thing for the main accounts and organizations tables:
	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @TableName + '_' + @ReferentialTableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']''))
	BEGIN	
		ALTER TABLE [dbo].[' + @TableName + ']  WITH CHECK ADD  CONSTRAINT [FK_' + @TableName + '_' + @ReferentialTableName + '] FOREIGN KEY([OrganizationId], [PartitionColumn])
			REFERENCES [dbo].[' + @ReferentialTableName + '] ([Id], [PartitionColumn])

		ALTER TABLE [dbo].[' + @TableName + '] CHECK CONSTRAINT [FK_' + @TableName + '_' + @ReferentialTableName + '] 
	END
	
	-- Recreate the full-text catalog if missing:
	IF NOT EXISTS (SELECT * FROM [PrePurchasing].[sys].[fulltext_catalogs] WHERE [name] LIKE ''' + @TableName + '%'')
		CREATE FULLTEXT CATALOG ' + @TableName +'_IdName_SDX
	
	-- Lastly recreate the table''s full-text search index:
	IF NOT EXISTS (
		SELECT * FROM sys.objects O 
		INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
		WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
	BEGIN
		CREATE FULLTEXT INDEX ON [dbo].[' + @TableName + ']
		([Id] LANGUAGE English, [Name] LANGUAGE English)
		KEY INDEX [' + @TableName + '_Id_UDX] ON (' + @TableName + '_IdName_SDX, FILEGROUP [PRIMARY])
		WITH (STOPLIST = SYSTEM, CHANGE_TRACKING = AUTO);
	END
	
	-- 
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Post_DownloadCommoditiesPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 29, 2012
-- Description:	Restoring Commodities indexes after downloading commodities data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Post_DownloadCommoditiesPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vCommodities_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = '', --Name of table being referenced; N/A in this case.
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server; N/A in this case.
	@PartitionColumn char(1) = 0, --Number to use for partition column; N/A in this case.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	-- First recreate table''s unique index:
	IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
	BEGIN
		CREATE UNIQUE NONCLUSTERED INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] 
		(
			[Id] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	END
	
	-- Secondly recreate the full-text catalog if missing:
	IF NOT EXISTS (SELECT * FROM [PrePurchasing].[sys].[fulltext_catalogs] WHERE [name] LIKE ''' + @TableName + '%'')
		CREATE FULLTEXT CATALOG ' + @TableName +'_IdName_SDX
	
	-- Lastly recreate the table''s full-text search index:
	IF NOT EXISTS (
		SELECT * FROM sys.objects O 
		INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
		WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
	BEGIN
		CREATE FULLTEXT INDEX ON [dbo].[' + @TableName + ']
		([Id] LANGUAGE English, [Name] LANGUAGE English)
		KEY INDEX [' + @TableName + '_Id_UDX] ON (' + @TableName + '_IdName_SDX, FILEGROUP [PRIMARY])
		WITH (STOPLIST = SYSTEM, CHANGE_TRACKING = AUTO);
	END
'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Post_DownloadOrganizationsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 22, 2012
-- Description:	Restoring Organizations FKs after downloading organizations data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Post_DownloadOrganizationsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vOrganizations_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = 'vAccounts', --Name of Accounts table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	-- First recreate main table FK index:
	IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
	BEGIN
		CREATE UNIQUE NONCLUSTERED INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] 
		(
			[Id] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	END
	
	-- Then recreate the FKs and check constraints:
	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_CustomFields_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[CustomFields]''))
	BEGIN
		ALTER TABLE [dbo].[CustomFields]  WITH CHECK ADD  CONSTRAINT [FK_CustomFields_' + @TableName + '] FOREIGN KEY([OrganizationId])
			REFERENCES [dbo].[' + @TableName + '] ([Id])
			
		ALTER TABLE [dbo].[CustomFields] CHECK CONSTRAINT [FK_CustomFields_' + @TableName + ']	
	END
		
	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_WorkgroupsXOrganizations_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[WorkgroupsXOrganizations]''))
	BEGIN
		ALTER TABLE [dbo].[WorkgroupsXOrganizations]  WITH CHECK ADD  CONSTRAINT [FK_WorkgroupsXOrganizations_' + @TableName + '] FOREIGN KEY([OrganizationId])
			REFERENCES [dbo].[' + @TableName + '] ([Id])
			
		ALTER TABLE [dbo].[WorkgroupsXOrganizations] CHECK CONSTRAINT [FK_WorkgroupsXOrganizations_' + @TableName + ']
	END
	
	IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_ConditionalApproval_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[ConditionalApproval]''))
	BEGIN
		ALTER TABLE [dbo].[ConditionalApproval]  WITH CHECK ADD  CONSTRAINT [FK_ConditionalApproval_' + @TableName + '] FOREIGN KEY([OrganizationId])
			REFERENCES [dbo].[' + @TableName + '] ([Id])
			
		ALTER TABLE [dbo].[ConditionalApproval] CHECK CONSTRAINT [FK_ConditionalApproval_' + @TableName + ']
	END
'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Post_DownloadVendorsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: March 01, 2012
-- Description:	Restoring Vendors indexes after downloading vendors data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Post_DownloadVendorsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vVendors_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = '', --Name of table being referenced; N/A in this case.
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server; N/A in this case.
	@PartitionColumn char(1) = 0, --Number to use for partition column; N/A in this case.
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	
	-- First recreate table''s unique index:
	IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
	BEGIN
		CREATE UNIQUE NONCLUSTERED INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] 
		(
			[Id] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	END
	
	-- Secondly recreate the full-text catalog if missing:
	IF NOT EXISTS (SELECT * FROM [PrePurchasing].[sys].[fulltext_catalogs] WHERE [name] LIKE ''' + @TableName + '%'')
		CREATE FULLTEXT CATALOG ' + @TableName +'_Name_SDX
	
	-- Lastly recreate the table''s full-text search index:
	IF NOT EXISTS (
		SELECT * FROM sys.objects O 
		INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
		WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
	BEGIN
		CREATE FULLTEXT INDEX ON [dbo].[' + @TableName + ']
		([Id] LANGUAGE English, [Name] LANGUAGE English)
		KEY INDEX [' + @TableName + '_Id_UDX] ON (' + @TableName + '_Name_SDX, FILEGROUP [PRIMARY])
		WITH (STOPLIST = SYSTEM, CHANGE_TRACKING = AUTO);
	END
'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Pre_DownloadAccountsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 22, 2012
-- Description:	Deleting Acounts FKs prior to downloading accounts data and swapping with load table.
-- Modifications: 2012-03-01 by kjt: Revised to include statements necessary to recreate full-text search catalog and indexes
-- =============================================
CREATE PROCEDURE [dbo].[usp_Pre_DownloadAccountsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vAccounts_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = 'vOrganizations', --Name of Organizations table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	-- Remove any referential table constraints for the main table:
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialTableName + '_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialTableName + ']''))
		ALTER TABLE [dbo].[' + @ReferentialTableName + '] DROP CONSTRAINT [FK_' + @ReferentialTableName + '_' + @TableName + ']
	
	-- Do the same for all the other tables with FK references to the main table:
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_WorkgroupAccounts_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[WorkgroupAccounts]''))
		ALTER TABLE [dbo].[WorkgroupAccounts] DROP CONSTRAINT [FK_WorkgroupAccounts_' + @TableName + ']

	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_Splits_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[Splits]''))
		ALTER TABLE [dbo].[Splits] DROP CONSTRAINT [FK_Splits_' + @TableName + ']
		
	--Drop the full-text index:
	IF  EXISTS (
		SELECT * FROM sys.objects O 
		INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
		WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
		DROP FULLTEXT INDEX ON [dbo].[' + @TableName + ']
		
	-- Lastly remove the main table''s FK index:
	IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
		DROP INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] WITH ( ONLINE = OFF )
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Pre_DownloadCommoditiesPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 29, 2012
-- Description:	Delete Commodities index prior to downloading Commodities data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Pre_DownloadCommoditiesPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vCommodities_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = '', -- N/A in this case 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server. -- N/A in this case
	@PartitionColumn char(1) = 0, --Number to use for partition column -- N/A in this case
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	--Drop the full-text index:
	IF  EXISTS (
	SELECT * FROM sys.objects O 
	INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
	WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
	DROP FULLTEXT INDEX ON [dbo].[' + @TableName + ']
	
	--Remove the table''s unique index:
	IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
		DROP INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] WITH ( ONLINE = OFF )
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Pre_DownloadOrganizationsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: February 22, 2012
-- Description:	Deleting Organizations FKs prior to downloading organizations data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Pre_DownloadOrganizationsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vOrganizations_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = 'vAccounts', --Name of Accounts table being referenced 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server.
	@PartitionColumn char(1) = 0, --Number to use for partition column
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	-- Remove any referential table constraints from the main table:
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_' + @ReferentialTableName + '_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[' + @ReferentialTableName + ']''))
		ALTER TABLE [dbo].[' + @ReferentialTableName + '] DROP CONSTRAINT [FK_' + @ReferentialTableName + '_' + @TableName + ']
	
	-- Do the same for all the other tables with FK references to the main table:
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_ConditionalApproval_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[ConditionalApproval]''))
		ALTER TABLE [dbo].[ConditionalApproval] DROP CONSTRAINT [FK_ConditionalApproval_' + @TableName + ']

	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_WorkgroupsXOrganizations_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[WorkgroupsXOrganizations]''))
		ALTER TABLE [dbo].[WorkgroupsXOrganizations] DROP CONSTRAINT [FK_WorkgroupsXOrganizations_' + @TableName + ']
		
	IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[dbo].[FK_CustomFields_' + @TableName + ']'') AND parent_object_id = OBJECT_ID(N''[dbo].[CustomFields]''))
		ALTER TABLE [dbo].[CustomFields] DROP CONSTRAINT [FK_CustomFields_' + @TableName + ']

	-- Lastly remove the main table''s FK index:
	IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
		DROP INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] WITH ( ONLINE = OFF )

	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_Pre_DownloadVendorsPartitionTable_Processing]...';


GO
-- =============================================
-- Author:		Ken Taylor
-- Create date: March 01, 2012
-- Description:	Delete Vendors index prior to downloading vendors data and swapping with load table.
-- =============================================
CREATE PROCEDURE [dbo].[usp_Pre_DownloadVendorsPartitionTable_Processing]
	-- Add the parameters for the stored procedure here
	@LoadTableName varchar(255) = 'vVendors_Load', --Table name of load table being loaded 
	@ReferentialTableName varchar(244) = '', -- N/A in this case 
	@LinkedServerName varchar(20) = 'FIS_DS', --Name of the linked DaFIS server. -- N/A in this case
	@PartitionColumn char(1) = 0, --Number to use for partition column -- N/A in this case
	@IsDebug bit = 0 --Set to 1 just print the SQL and not actually execute it. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @TableName varchar(255) = SUBSTRING(@LoadTableName, 0, CHARINDEX('_Load',@LoadTableName ))
	DECLARE @TSQL varchar(MAX) = ''

    -- Insert statements for procedure here
	SELECT @TSQL = '
	--Drop the full-text index:
	IF  EXISTS (
	SELECT * FROM sys.objects O 
	INNER JOIN sys.fulltext_indexes FTI ON O.object_id = FTI.object_id
	WHERE O.object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND O.type in (N''U'')
	)
	DROP FULLTEXT INDEX ON [dbo].[' + @TableName + ']
	
	--Remove the table''s unique index:
	IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''[dbo].[' + @TableName + ']'') AND name = N''' + @TableName + '_Id_UDX'')
		DROP INDEX [' + @TableName + '_Id_UDX] ON [dbo].[' + @TableName + '] WITH ( ONLINE = OFF )
	'
	
	-------------------------------------------------------------------------
	if @IsDebug = 1
		BEGIN
			--used for testing
			PRINT @TSQL	
		END
	else
		BEGIN
			--Execute the command:
			EXEC(@TSQL)
		END 
END
GO
PRINT N'Creating [dbo].[usp_ProcessEmails]...';


GO
CREATE PROCEDURE [dbo].[usp_ProcessEmails]
	
	@perevent bit = 0,
	@daily bit = 0,
	@weekly bit = 0

AS

	-- declare variables
	declare @pcursor cursor, @userid varchar(10), @text varchar(max), @body varchar(max), @email varchar(50)
	declare @ntype varchar(50)

	-- determine which type/interval we are sending out
	if (@perevent = 1)
	begin
		set @ntype = 'perevent'
	end
	else if (@daily = 1)
	begin
		set @ntype = 'daily'
	end
	else if (@weekly = 1)
	begin
		set @ntype = 'weekly'
	end
	else
	begin
		return 0
	end

	-- find the distinct people that have messages pending		
	set @pcursor = cursor for
		select distinct emailqueue.userid, users.email 
		from emailqueue 
			inner join Users on users.Id = emailqueue.UserId
		where pending = 1 and lower(notificationtype) = @ntype
	
	open @pcursor

	fetch next from @pcursor into @userid, @email

	while(@@FETCH_STATUS = 0)
	begin

		set @text = null
	
		-- get the individual notifications into a li
		select @text = coalesce(@text + '</li><li>', '<li>') + [text]
		from emailqueue where pending = 1 and lower(notificationtype) = @ntype and userid = @userid
	
		-- build up the body of the email
		set @body = null
		set @body = '<p>Here is your summary for the PrePurchasing system.</p><ul>'
		set @body = @body + @text
		set @body = @body + '</li></ul> <p>-The PrePurchasing System</p>'

		-- execute the send
		exec msdb.dbo.sp_send_dbmail
			@profile_name = 'Opp No Reply',
			@recipients = @email,
			@subject = 'PrePurchasing Notifications',
			@body = @body,
			@body_format = 'HTML'

		-- mark the messages as sent
		update EmailQueue set Pending = 0, DateTimeSent = GETDATE() where Pending = 1 and LOWER(NotificationType) = @ntype and UserId = @userid

		fetch next from @pcursor into @userid, @email

	end

	close @pcursor
	deallocate @pcursor

RETURN 0
GO
PRINT N'Creating [dbo].[usp_ProcessOrgDescendants]...';


GO
CREATE PROCEDURE [dbo].[usp_ProcessOrgDescendants]

AS

	/*

		Recursively try to find all descendants of a parent org
		http://blogs.msdn.com/b/securitytools/archive/2009/06/23/traversing-a-recursive-table-self-reference-using-t-sql.aspx

	*/

	-- reset the table seed
	truncate table vorganizationdescendants
	DBCC CHECKIDENT(vorganizationdescendants, reseed, 1)

	declare @cursor cursor, @top varchar(10)
	declare @descendants table (orgid varchar(10), name varchar(max), immediateparent varchar(10), isactive bit)

	set @cursor = cursor for
		select distinct parentid from vorganizations where parentid is not null

	open @cursor

	fetch next from @cursor into @top

	while(@@FETCH_STATUS = 0)
	begin

		-- clear the table
		delete from @descendants

		-- get the immediate descendants
		insert into @descendants
		select child.id, child.name, child.parentid, child.IsActive 
		from vorganizations parent
			inner join vorganizations child on child.parentid = parent.id
		where parent.id = @top

		-- get all the descendants recursively
		while @@ROWCOUNT > 0
		BEGIN

			insert into @descendants (orgid, name, immediateparent, isactive)
			select child.id, child.name, child.parentid, child.IsActive
			from @descendants parent
				inner join vorganizations child on child.parentid = parent.orgid
							and not exists ( select parent2.orgid from @descendants parent2 where parent2.orgid  = child.id )	

		END

		-- insert the top
		insert into vorganizationdescendants (orgid, name, immediateparentid, rollupparentid, IsActive)
		select id, name, null, @top, IsActive
		from vOrganizations
		where id = @top

		-- insert into descendants
		insert into vorganizationdescendants (orgid, name, immediateparentid, rollupparentid, IsActive)
		select orgid, name, immediateparent, @top, isactive from @descendants

		-- insert itself

		fetch next from @cursor into @top

	end

	close @cursor
	deallocate @cursor

	-- insert all the orgs that don't have anything report to it
	insert into vOrganizationDescendants(OrgId, Name, ImmediateParentId, RollupParentId, IsActive)
	select id, Name, ParentId, id, 1 from vorganizations where id not in (
		select distinct parentid from vorganizations where parentid is not null
	)


RETURN 0
GO
PRINT N'Creating [dbo].[usp_SyncWorkgroupAccounts]...';


GO
CREATE PROCEDURE [dbo].[usp_SyncWorkgroupAccounts]
AS

declare @cursor cursor, @id int

set @cursor = cursor for
	select workgroups.id from workgroups where syncaccounts = 1

open @cursor

fetch next from @cursor into @id

while(@@FETCH_STATUS = 0)
begin

	-- insert the new ones
	merge workgroupaccounts as t
	using (
		select w.id workgroupid, va.id accountid
		from workgroups w
			inner join WorkgroupsXOrganizations wo on w.id = wo.WorkgroupId
			inner join vAccounts va on wo.OrganizationId = va.OrganizationId
		where w.id = @id
		  and va.isactive = 1
		) as src
	on t.workgroupid = src.workgroupid and t.accountid = src.accountid
	when not matched then 
		insert (accountid, workgroupid) values (src.accountid, src.workgroupid);

	-- remove the inactive ones
	delete from WorkgroupAccounts
	where id in (select wa.id from WorkgroupAccounts wa inner join vAccounts va on wa.AccountId = va.id where va.IsActive = 0 and wa.WorkgroupId = @id)

	fetch next from @cursor into @id

end

close @cursor
deallocate @cursor



RETURN 0
GO
PRINT N'Creating Permission...';


GO
GRANT CONNECT TO [dbo]
    AS [dbo];


GO
PRINT N'Creating [dbo].[vPendingOrders].[MS_DiagramPaneCount]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPaneCount', @value = 1, @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'vPendingOrders';


GO
PRINT N'Creating [dbo].[vPendingOrders].[MS_DiagramPane1]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPane1', @value = N'[0E232FF0-B466-11cf-A24F-00AA00A3EFFF, 1.00]
Begin DesignProperties = 
   Begin PaneConfigurations = 
      Begin PaneConfiguration = 0
         NumPanes = 4
         Configuration = "(H (1[40] 4[20] 2[20] 3) )"
      End
      Begin PaneConfiguration = 1
         NumPanes = 3
         Configuration = "(H (1 [50] 4 [25] 3))"
      End
      Begin PaneConfiguration = 2
         NumPanes = 3
         Configuration = "(H (1 [50] 2 [25] 3))"
      End
      Begin PaneConfiguration = 3
         NumPanes = 3
         Configuration = "(H (4 [30] 2 [40] 3))"
      End
      Begin PaneConfiguration = 4
         NumPanes = 2
         Configuration = "(H (1 [56] 3))"
      End
      Begin PaneConfiguration = 5
         NumPanes = 2
         Configuration = "(H (2 [66] 3))"
      End
      Begin PaneConfiguration = 6
         NumPanes = 2
         Configuration = "(H (4 [50] 3))"
      End
      Begin PaneConfiguration = 7
         NumPanes = 1
         Configuration = "(V (3))"
      End
      Begin PaneConfiguration = 8
         NumPanes = 3
         Configuration = "(H (1[56] 4[18] 2) )"
      End
      Begin PaneConfiguration = 9
         NumPanes = 2
         Configuration = "(H (1 [75] 4))"
      End
      Begin PaneConfiguration = 10
         NumPanes = 2
         Configuration = "(H (1[66] 2) )"
      End
      Begin PaneConfiguration = 11
         NumPanes = 2
         Configuration = "(H (4 [60] 2))"
      End
      Begin PaneConfiguration = 12
         NumPanes = 1
         Configuration = "(H (1) )"
      End
      Begin PaneConfiguration = 13
         NumPanes = 1
         Configuration = "(V (4))"
      End
      Begin PaneConfiguration = 14
         NumPanes = 1
         Configuration = "(V (2))"
      End
      ActivePaneConfig = 0
   End
   Begin DiagramPane = 
      Begin Origin = 
         Top = 0
         Left = 0
      End
      Begin Tables = 
      End
   End
   Begin SQLPane = 
   End
   Begin DataPane = 
      Begin ParameterDefaults = ""
      End
      Begin ColumnWidths = 9
         Width = 284
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
      End
   End
   Begin CriteriaPane = 
      Begin ColumnWidths = 11
         Column = 1440
         Alias = 900
         Table = 1170
         Output = 720
         Append = 1400
         NewValue = 1170
         SortType = 1350
         SortOrder = 1410
         GroupBy = 1350
         Filter = 1350
         Or = 1350
         Or = 1350
         Or = 1350
      End
   End
End', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'vPendingOrders';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[Approvals] WITH CHECK CHECK CONSTRAINT [FK_Approvals_Splits];

ALTER TABLE [dbo].[Approvals] WITH CHECK CHECK CONSTRAINT [FK_Approvals_OrderStatusCodes];

ALTER TABLE [dbo].[Attachments] WITH CHECK CHECK CONSTRAINT [FK_Attachments_Users];

ALTER TABLE [dbo].[Attachments] WITH CHECK CHECK CONSTRAINT [FK_Attachments_Orders];

ALTER TABLE [dbo].[AutoApprovals] WITH CHECK CHECK CONSTRAINT [FK_AutoApprovals_Users1];

ALTER TABLE [dbo].[AutoApprovals] WITH CHECK CHECK CONSTRAINT [FK_AutoApprovals_Users];

ALTER TABLE [dbo].[ConditionalApproval] WITH CHECK CHECK CONSTRAINT [FK_ConditionalApproval_vOrganizations];

ALTER TABLE [dbo].[ConditionalApproval] WITH CHECK CHECK CONSTRAINT [FK_ConditionalApproval_Workgroups];

ALTER TABLE [dbo].[ConditionalApproval] WITH CHECK CHECK CONSTRAINT [FK_ConditionalApproval_Users];

ALTER TABLE [dbo].[ConditionalApproval] WITH CHECK CHECK CONSTRAINT [FK_ConditionalApproval_SecondaryUser];

ALTER TABLE [dbo].[ControlledSubstanceInformation] WITH CHECK CHECK CONSTRAINT [FK_AuthorizationNumbers_Orders];

ALTER TABLE [dbo].[CustomFieldAnswers] WITH CHECK CHECK CONSTRAINT [FK_CustomFieldAnswers_Orders];

ALTER TABLE [dbo].[CustomFieldAnswers] WITH CHECK CHECK CONSTRAINT [FK_CustomFieldAnswers_CustomFields];

ALTER TABLE [dbo].[CustomFields] WITH CHECK CHECK CONSTRAINT [FK_CustomFields_vOrganizations];

ALTER TABLE [dbo].[EmailQueue] WITH CHECK CHECK CONSTRAINT [FK_EmailQueue_Users];

ALTER TABLE [dbo].[EmailQueue] WITH CHECK CHECK CONSTRAINT [FK_EmailQueue_Orders];

ALTER TABLE [dbo].[KfsDocuments] WITH CHECK CHECK CONSTRAINT [FK_DocumentNumbers_Orders];

ALTER TABLE [dbo].[LineItems] WITH CHECK CHECK CONSTRAINT [FK_LineItems_Orders];

ALTER TABLE [dbo].[Notifications] WITH CHECK CHECK CONSTRAINT [FK_Notifications_Users];

ALTER TABLE [dbo].[OrderComments] WITH CHECK CHECK CONSTRAINT [FK_OrderComments_Users];

ALTER TABLE [dbo].[OrderComments] WITH CHECK CHECK CONSTRAINT [FK_OrderComments_Orders];

ALTER TABLE [dbo].[OrderRequestSaves] WITH CHECK CHECK CONSTRAINT [FK_OrderRequestSaves_Users1];

ALTER TABLE [dbo].[OrderRequestSaves] WITH CHECK CHECK CONSTRAINT [FK_OrderRequestSaves_Users];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_Approvals];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_Workgroups];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_WorkgroupVendors];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_WorkgroupAddresses];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_ShippingTypes];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_OrderTypes];

ALTER TABLE [dbo].[Orders] WITH CHECK CHECK CONSTRAINT [FK_Orders_OrderStatusCodes];

ALTER TABLE [dbo].[OrderTracking] WITH CHECK CHECK CONSTRAINT [FK_OrderTracking_Users];

ALTER TABLE [dbo].[OrderTracking] WITH CHECK CHECK CONSTRAINT [FK_OrderTracking_Orders];

ALTER TABLE [dbo].[OrderTracking] WITH CHECK CHECK CONSTRAINT [FK_OrderTracking_OrderStatusCodes];

ALTER TABLE [dbo].[Splits] WITH CHECK CHECK CONSTRAINT [FK_Splits_LineItems];

ALTER TABLE [dbo].[Splits] WITH CHECK CHECK CONSTRAINT [FK_Splits_Orders];

ALTER TABLE [dbo].[Splits] WITH CHECK CHECK CONSTRAINT [FK_Splits_vAccounts];

ALTER TABLE [dbo].[vAccounts] WITH CHECK CHECK CONSTRAINT [FK_vAccounts_vOrganizations];

ALTER TABLE [dbo].[WorkgroupAccounts] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupAccounts_vAccounts];

ALTER TABLE [dbo].[WorkgroupAccounts] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupAccounts_Workgroups];

ALTER TABLE [dbo].[WorkgroupAddresses] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupAddresses_Workgroups];

ALTER TABLE [dbo].[WorkgroupAddresses] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupAddresses_States];

ALTER TABLE [dbo].[WorkgroupPermissions] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupPermissions_Workgroups];

ALTER TABLE [dbo].[WorkgroupPermissions] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupPermissions_Users];

ALTER TABLE [dbo].[WorkgroupPermissions] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupPermissions_Roles];

ALTER TABLE [dbo].[WorkgroupsXOrganizations] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupsXOrganizations_vOrganizations];

ALTER TABLE [dbo].[WorkgroupsXOrganizations] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupsXOrganizations_Workgroups];

ALTER TABLE [dbo].[WorkgroupVendors] WITH CHECK CHECK CONSTRAINT [FK_WorkgroupVendors_Workgroups];


GO
PRINT N'Update complete.'
GO
